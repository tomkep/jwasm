
   Changelog

   09/20/2008, v1.92:

   Bugfixes:
   -  if an assembly time variable was assigned a value which doesn't
      fit in 32bits, the assignment failed.
   -  for some instructions a forward reference to a variable might
      have caused error "invalid instruction operands".
   -  a '&' after (or before?) a double quote in a macro might have
      confused JWasm and prevented a parameter or local to be replaced by the
      current value.
   -  in a C expression, operators && and || weren't detected if
      immediately followed by a '(' or '['.
   -  MOV <seg_reg>, <memory> and MOV <memory>, <seg_reg> caused
      error 'invalid instruction operands' in v1.8 - v1.91 if <memory> was
      a forward reference.
   -  the linux binaries in v1.9 and v1.91 caused a "segmentation
      fault" if JWasm tried to display an error.
   -  offset operator didn't skip a label's type information. So
      "mov eax,[esi+offset buffer]" was rejected if TYPE of buffer wasn't 4.
   -  for INVOKE, it was detected if EAX was overwritten, but AX
      wasn't checked.
   -  register arguments in INVOKE weren't expanded (for 32bit code,
      an 8bit or 16bit register must be expanded to 32bit; for 16bit code,
      an 8bit register must be expanded to 16bit).
   -  due to special handling of INCLUDE and INCLUDELIB arguments macro
      functions and text macros didn't work as expected after these
      directives.
   -  OPTION EPILOGUE:NONE did translate RET to RET <nnn>.
   -  if the '=' directive was used to assign a relocatable value to a
      variable, usage of OFFSET operator in the expression caused error
      "constant expected".
   -  the epilogue code generated by RET wasn't parsed immediately
      if the instruction was located inside a FOR|REPEAT|WHILE loop.
   -  the code which detected local macros wasn't safe and didn't
      account for '&' operators or macro function calls before the MACRO
      keyword.
   -  in v1.91, evaluation operator % used before a text macro name did
      double the '!' if the text macro was a parameter in a string macro
      function call.
   -  in v1.90 and v1.91, "literal concatenation" - a literal enclosed
      in <> or {} is continued if last non-space character of the line
      is a comma - didn't work for data initializers.
   -  INCLUDE directive in a FOR/REPEAT/WHILE loop didn't immediatedly
      include the file's content, but waited until the loop was finished.
   -  if an error occured inside a macro the line number displayed was
      one too high.
   -  if a parameter for a string function (CATSTR, SUBSTR, ...) is a
      text macro id, the "evaluated" value of the existing id is to be
      assigned to the new id. The "depth" of the evaluation has been
      adjusted to almost match Masm, but there are still small differences.
   -  if a macro parameter had an invalid name, no error was displayed.
   -  if a macro parameter was followed by a ':', no error was displayed
      if the token following wasn't '=', REQ or VARARG.
   -  if the rvalue of EQU contained a text equate name, the lvalue became
      also a text equate. Now the rvalue is expanded and THEN tested if
      it evaluates to a numeric value.
   -  array initializers within struct initializers had problems to
      detect the end of the initialization string.
   -  if a literal missed the closing delimiter '>' or '}', it was always
      flagged as an error, which turned out to be too restrictive.
   -  syntax "mov eax,4(5)" was rejected (brackets allow to omit the
      '+' operator).
   -  in the line "ifaneb EQU .if eax != ebx" the exclamation char was
      lost because the rvalue is stored as a string enclosed in <>, which
      requires that '!' are doubled.
   -  errors which occured when the listing file was opened were ignored.
   -  type comparison of public data items which also had an externdef entry 
      was too rigid and often failed for arbitrary types.
   -  for INVOKE, if an address was to be pushed (ADDR operator) and the
      parameter wasn't declared FAR, just the offset was pushed. Now the
      segment part is also pushed if the parameter's size is > @wordsize
      (which is 4 in 32bit and 2 in 16bit).
   -  for INVOKE, if cpu was < 80386 and a dword-sized constant value had 
      to be pushed, there was a risk that the value was calculated wrong.
   -  simplified segment directives didn't accept segment names beginning
      with a dot.
   -  syntax "invoke (ExitProcess)" wasn't accepted.

   Other changes:
   -  MSVC.MAK has been adjusted to make it compatible with NMAKE v8 of
      MS VC++ EE 2005. Additionally, the source has been modified: header
      file windows.h is no longer used and thus the MS PSDK isn't needed
      anymore.
   -  MAKEFILE has been adjusted to allow to create the JWasm DOS version
      with native WLINK cmdline options.
   -  INCLUDELIB library paths are no longer added to the symbol table.
   -  PARITY? and OVERFLOW? supported.
   -  names for macro locals now consist of a "??" prefix and a hexadecimal
      number suffix. Previously it was a decimal number suffix.
   -  fatal error displayed if writes to the object module are failing.
   -  WIN16.ASM sample added.

   08/19/2008, v1.91:

   Bugfixes:
   -  for /elf, section flag WRITEABLE wasn't set for .data and .bss.
   -  for /elf, self-relative fixups need an inline addend of -4
      which was missing.
   -  POPAW opcode was missing and POPA was always encoded as 16bit.
   -  ORG outside segment block was accepted without error.
   -  SizeStr and InStr lines were doubled in listing.
   -  for INSTR, value of optional <start> parameter was ignored.
   -  AT was handled as a separate segment attribute, not as a
      combine type value like PUBLIC or COMMON.
   -  address value of segment attribute AT wasn't calculated
      correctly.
   -  there was a severe risk that the code generated by the hll
      directives wasn't parsed immediately if the directive was inside a
      FOR|REPEAT|WHILE loop.
   -  ALIGN/EVEN inside a STRUCT did set the struct's alignment
      value. This isn't the way Masm does it. Now it'll adjust the offset
      of the next field only.
   -  if "far call optimization" or "automatic jump expansion" occured
      in a FOR|REPEAT|WHILE loop, wrong code might have been generated.
   -  in v1.9, "far call optimization" and "automatic jump expansion"
      might have caused wrong code to be generated if a forward reference
      was involved.
   -  for output formats COFF and ELF, relocateable items referencing
      an assembly time variable were always fixed with the variable's final
      value, which is an error.
   -  JWasm didn't complain if a label was reused as an assembly
      time variable. Also no complains if an equate defined with the EXTERN
      directive was redefined.
   -  symbol '$' used inside a STRUCT definition always returned 0,
      but should return the struct's current offset instead.
   -  ORG inside a STRUCT definition didn't set the struct's
      current offset.
   -  in a hll logical expression, just the first operand was
      examined if it is a signed value, the second operand was ignored.
   -  a buffer overflow occured if the total size of a translated
      hll expression exceeded 512.
   -  operands for LxS instructions weren't checked for matching
      sizes.
   -  macro labels did work in the first macro level only. (Since
      FOR, REPEAT and WHILE loops are - technically - local macros, GOTOs
      didn't work within such loops if they were embedded in a macro.)
   -  EXITM/GOTO in a macro didn't prevent expression evaluation for
      conditional assembly directives in the lines after EXITM/GOTO and
      before ENDM. This might have caused message "text item required" to
      appear.
   -  if a macro parameter was a macro function and the expansion
      operator (%) was put before the macro, the expansion was skipped.

   Other changes:
   -  TextEqu, CatStr, InStr, SizeStr, SubStr macros will now accept text
      literals enclosed in <> only, to increase Masm compatibility. Literals
      enclosed in quotes or {} are rejected ("text item required").
   -  To avoid problems with angle brackets inside literals the macro
      functions @CatStr, @InStr, @SizeStr and @SubStr have been changed
      to internal functions.
   -  Max. parameters for @CatStr() increased from 10 to 20.
   -  /bin cmdline parameter added.
   -  for INSTR/@INSTR/SUBSTR/@SUBSTR, if value of <start> parameter is
      larger than size of string, an error is displayed now.
   -  for SUBSTR/@SUBSTR, if value of <count> parameter is too large,
      an error is displayed now. Also, parameter <size> must be >= 0.
   -  support for .ALPHA implemented.
   -  REAL4, REAL8 and REAL10 will accept floating-point initializers
      only.
   -  ALIGN will now use one-instruction no-op "lea esp,[esp+00000000]"
      for a 7-byte filler in 32bit code segments.
   -  NDEBUG wasn't defined in release version, which caused assert()
      to be active and thus bloating the binary by 5 kB.

   07/24/2008, v1.9:

   Bugfixes:
   -  a forward jump to a PROC label which wasn't reachable with
      a short jump might have caused invalid code to be generated.
   -  for OMF, if a starting address was specified, there was
      a MODEND record emitted anyway, but for 32bit segments it must
      be a MODE32 record, else the highword of the address' offset
      is ignored.
   -  if a data item contained a label offset and the item's size
      was >= 4, there was a 32bit fixup record generated, no matter what
      the label's segment was telling about the offset's magnitude.
   -  an equate with format <name> EQU <override>:[number], that
      is, the value is an address without a symbol, caused an exception.
   -  "nested" procedures are no longer supported (actually, they
      never were, but now an error is displayed).
   -  opcode PUSHAW was missing.
   -  PUSHA always generated the 16-bit form. In Masm PUSHA will
      generate PUSHAW in 16-bit segments and PUSHAD in 32-bit segments.
   -  procedure parameters which were function pointers weren't
      accepted by INVOKE.
   -  if a label was defined which had an associated EXTERNDEF,
      the optional language specifier of the EXTERNDEF wasn't used.
   -  optional simple expression after .UNTILCXZ was ignored.
   -  if the difference of two offsets was calculated, it wasn't
      ensured that the two labels are in the same segment.
   -  operator LROFFSET was accepted, but handled just like the
      OFFSET operator.
   -  parameters for OPTION directive weren't expanded.
   -  if the RVALUE of a '=' directive wasn't a constant number,
      error message "undefined symbol" was displayed. Changed to message
      "constant expected".
   -  literal character operator ('!') wasn't handled the way Masm
      does. So sometimes a '!' in a literal got "lost".
   -  padding a struct with bytes because of alignment didn't work
      reliably.
   -  an undefined segment in a group wasn't flagged as error.
   -  || operator in .WHILE didn't work reliable.
   -  if a start label is emitted undecorated in /coff and its
      language type is NONE, the underscore prefix must be omitted which
      wasn't done.
   -  syntax errors in control-flow directives (.IF, .WHILE, ...)
      weren't noticed sometimes.
   -  if an assembly error occured in a line which contained a %s
      and -Fl switch was set, a GPF might have occured.
   -  .model parameter FARSTACK didn't set text equate @stack to
      'STACK'.
   -  stack segment was added to DGROUP even if .model parameter
      FARSTACK was set.
   -  changing language with <OPTION language> didn't update assembly
      time variable @Interface.

   Other changes:
   -  if instruction is RET[F] <value> and <value> is 0 (and it is not
      external, it's now optimized to the one-byte short RET[F].
   -  EXTERNDEF's type comparison was too rigid for arbitrary types.
      Now a symbol type conflict will be reported only if the base types
      differ.
   -  type modifiers for DWORD data items containing label addresses will
      now affect code generation.
   -  reserved words EQU2, .XMM2 and .XMM3 (all WASM specific) removed.
   -  error message texts no longer stored as string resources.
   -  there's now a JWasm binary for Linux available, distributed in a
      separate package.
   -  speed optimisation: the second and further passes will no longer
      scan the full source.
   -  the DOS binary JWASMD.EXE now includes the HDPMI DOS extender code,
      making it a stand-alone binary.
   -  directives ELSEIF1, ELSEIF2, .ERR1 and .ERR2 supported.
   -  -Zi option added (currently it's a no-op).
   -  better syntax check for the NAME directive to help to avoid using
      this reserved name as an identifier.
   -  IMAGEREL and SECTIONREL operators supported for /coff.
   -  previous versions allowed instruction names used as labels. This
      has been deactivated.
   -  -Zp[n] option added.
   -  structure fields are displayed in standard listing, not just in
      symbol-table listing.
   -  for /coff, default library names are now enclosed in double quotes
      only if the name contains a space (some linkers have problems with
      the quotes).
   -  OPTION NOKEYWORD now works with all reserved words.
   -  improved syntax check for parameters of OPTION directive.
   -  ELF output format supported.
   -  OPTION NOREADONLY and OPTION NOOLDMACROS accepted (dummies).
   -  cmdline option -G<c|d|z> implemented.
   -  PUSHCONTEXT/POPCONTEXT implemented.
   -  level of warning 'cannot access label with segment registers' changed
      from 3 to default level 2.

   06/21/2008, v1.8:

   Bugfixes:
   -  expression after .BREAK/.CONTINUE wasn't evaluated correctly
      if it contained "&&" or "||" operators.
   -  if a userdefined prologue macro was executed, the first
      line of the procedure was "lost".
   -  the value returned by a userdefined prologue macro function
      was ignored.
   -  a forward reference to a segment name caused a "General
      Failure" error.
   -  a text symbol defined with cmdline parameter -D got default
      value <1> if no value was specified, which isn't what Masm does.
      Now <> is assigned.
   -  bugfix (known bug): syntax
        mov eax, [edi.<TYPE>].<Field_name>
      is accepted now.
   -  bugfix (known bug): sometimes a superfluous type name wasn't skipped,
      resulting in an error msg of "Symbol <TYPE>.<TYPE> is not defined".
   -  bugfix (known bug): a macro function had always to be called with
      parameters enclosed in brackets, even if EXITM will return nothing.
      This has been corrected.
   -  TYPE operator didn't accept register or type operands.
   -  if there were both an EXTERNDEF and a PUBLIC definition for
      a symbol, a PUBDEF entry was added to the object module, even if the
      symbol wasn't defined in the module.
   -  LENGTH operator didn't accept a structure field.
   -  communal variables were stored in one COMDEF record, no matter
      how large this record might have grown. Now it is ensured that record
      size won't exceed 1024.
   -  forward reference of a label in a LxS instructions failed
      with error 'invalid instruction operands'.
   -  labels in data items were stored without optional offset.
   -  FLAT as a group override ("mov eax, offset FLAT:<symbol>")
      was rejected.
   -  '%' used as COMMENT delimiter didn't work.
   -  alignment was ignored if the offset of a nested structure
      was to be calculated.
   -  COMMENT directive wasn't recognized in an inactive IF block.
   -  an invalid optimization was triggered if a question mark was
      the last of multiple items in a DUP argument (i.e. "DUP (?,?)"). As
      a result, the total amount of space reserved was too short.
   -  in 16bit code segments, value 0xFC was used to pad 1 byte,
      which is the CLD instruction. Now 0x90 (NOP) is used.
   -  a typecast to force JWasm to use the long format of an
      instruction was ignored. Example:
        cmp ax,1          ; the "short" (byte) format (83 F8 01) is used
        cmp ax,word ptr 1 ; the "long" (word) format (3D 0001) is to be used
      Now the typecast will make JWasm create the "long" format.
   -  .STARTUP created wrong code for TINY model.
   -  field initializer for a bit-field in a RECORD definition was
      accepted, but wasn't stored.
   -  if a PROC parameter had no explicit type associated with it
      (that is, the ":<type>" part was missing), then JWasm's behavior tended
      to be hazardous due to the usage of uninitialized stack variables.
   -  if the fields in a RECORD didn't total exactly to 8,16 or 32,
      the record wasn't shifted right.
   -  a label before a .ERRxx directive caused a syntax error.
   -  bugfix (known bug): labels in lines containing a "conditional assembly"
      directive (IF, ELSE, ENDIF, ...) were ignored.
   -  if a memory operand was pushed/poped, there was no type check.
      So memory items with sizes < WORD or > DWORD were accepted.
   -  stack <stacksize> reported error "constant operand expected"
      if stacksize wasn't a single number.
   -  stacksize stored for stack segments was a 16bit value only.
   -  macro parameter expansion operator % might have caused a GPF
      if the parameter was the last one and was intended to convert a number
      to a literal.
   -  lines with the FOR/FORC directives were expanded. This was a
      problem if the directive's first parameter was a valid text macro name.
   -  COMMENT delimiter wasn't detected if it was located behind
      a ';'.
   -  if a numeric equate's magnitude exceeded 32bit, the high bits
      were skipped. Now the equate will be stored as a text macro in this
      case.
   -  there was no parameter syntax check for [ELSE]IFIDN[I], 
      [ELSE]IFDIF[I], [ELSE]IFB, [ELSE]IFNB.
   -  if a segment was open when the END directive was detected, 
      the segment's content was skipped, no error message was displayed.
   -  if a FOR parameter string contained a call of a macro function
      which had more than 1 parameter, a syntax error occured.
   -  parameter syntax check for .ERRxx directive was missing.
   -  .ERRDEF and .ERRNDEF checked whether the symbol was defined
      in all passes, but this can't be done in pass one due to possible
      forward references.
   -  initialization of a structure/union embedded in another
      structure might have failed if there were leading spaces before the
      initialization string.
   -  a text macro defined with cmdline option -D must not have
      contained a '-' or '/'.
   -  code for ALIAS didn't check whether the alias name was defined
      elsewhere in the source.
   -  logical operators EQ, NE, LT, LE, GT, GE did accept constant
      operands only, but they must also work with relocatable direct
      addresses.
   -  there was a chance that an invalid OMF record was written
      if lots of externals were defined which exceeded the max size of one
      record.
   -  if a byte array in a structure was initialized with a string,
      there were too many bytes emitted.

   Other changes:
   -  error msg 'Too many arguments to INVOKE' displayed instead of just
      'Syntax error'.
   -  undefined publics are now flagged as error when the PUBLIC directive
      occurs in the source, not at the end of assembly pass one.
   -  if the expression after .WHILE is a constant value != 0, the initial
      jump to test the condition is superfluous and is skipped now. Same
      behavior as Masm.
   -  cmdline options -Wn, -w and -WX synch'ed with Masm, option -we deleted.
   -  added missing directives .LALL, .NOLISTMACRO and .NOLISTIF.
   -  source modules in subdirs WATCOM and WOMP included to the project,
      so object modules in WATCOM and WOMP could be deleted.
   -  string resource handling switched to native Win32, WRES.LIB no longer
      necessary and deleted.
   -  speed boost achieved (reduced number of necessary passes) by better
      handling of forward references.
   -  GOTO supported.
   -  more than one source file in the command line accepted.
   -  directive .UNTILCXZ supported.
   -  operator THIS implemented.
   -  OPTION LANGUAGE:<language> implemented.
   -  OPTION SEGMENT:<segSize> implemented.
   -  OPTION M510/NOM510 implemented
   -  OPTION OLDSTRUCTS/NOOLDSTRUCTS implemented.
   -  OPTION SCOPED/NOSCOPED implemented.
   -  OPTION LJMP/NOLJMP implemented.
   -  OPTION EMULATOR/NOEMULATOR implemented.
   -  .RADIX 10 accepted (it's a noop).
   -  -Zm, -Sn, -nologo, -zlf, -zls options added.
   -  -zz option renamed to -zzp for consistency.
   -  -omf, -coff options added
   -  -bt option removed.
   -  -Sg, -c added (noops)
   -  listing is supported.
   -  default for floating point instructions has been changed to -FPi87,
      that is, no emulator fixups are created.
   -  initialization for RECORD data items implemented.
   -  support for COFF output format implemented.
   -  code generated by .STARTUP is now similar to what Masm creates.
   -  support for segment attribute IGNORE removed.
   -  predefined numeric equate @WordSize added

   05/20/2008, v1.7 (initial):

    Changes in JWasm compared to Open Watcom's WASM.

    Bugfixes:
    - string equates now handled the way MASM does.
    - fixup of start address now refers to the group of the start 
      address's segment. WASM still has problems if the
      start address is in a segment which isn't the first one in a group.
    - EXTERNDEFs which aren't referenced in the source now won't
      cause a EXTDEF entry to be created in the object module.
    - EXTERNDEFs for a symbol which were contained several times in the
      source caused several PUBDEFs to be created in the object module if
      the symbol was actually defined.
    - SIZEOF (sometimes?) returned double the size of a variable.
    - structure field names were stored in the global symbol table.
      This caused various problems and often bad code was created.
    - some "reserved" words in WASM, which aren't reserved in MASM
      were removed from this list: "ERROR", "PRIVATE", "COMMON", "EXPORT",
      "READONLY", "IGNORE", "CASEMAP", "SMALL", "MEMORY", "COMPACT", "ABS",
      "NOTHING", "MEDIUM", "LARGE", "TINY", "HUGE", "USES", "FARSTACK", 
      "NEARSTACK", "OS_DOS", "OS_OS2".
    - symbol type conflicts are now detected and reported as errors.
    - default type of LOCAL variables was always WORD.
    - alignment of LOCAL variables wasn't MASM-like.
    - quotes and curly-bracket delimiting strings were removed during
      the tokenisation process. This isn't MASM compatible.
    - string equates were "evaluated" very early, making it impossible to
      define a string equate which contained another string equate.
    - a macro local caused a text equate with identical name to be generated
      or changed. This side-effect wasn't expected.
    - WASM needed ':REQ' in capitals to make a macro parameter "required".
      MASM is not case sensitive here.
    - macro parameters in the macro definition were expanded, which is a 
      bad idea. Thus it was impossible to give macro parameters a name
      which was already used in the namespace (for example the name of a
      previously defined macro).
    - a macro name given as parameter in a IFDEF/IFNDEF line was "evaluated".
    - if a source line ends with a comma, it was generally concatenated with
      the next line. This caused problems with invokation of macros with
      "empty" arguments. The automatic concatenation is now just done if
      a text item (enclosed in <> or {}) is still open at the end of the
      line and last character of the line is a comma.
    - the object module to write was not always deleted if an error occured.
    - arrays with 0 items caused a GPF.
    - macros couldn't be redefined.
    - number suffix 't' to define a decimal number) was not implemented.
    - ALIAS directive syntax differed from MASM's.
    - it was impossible to have a PROC with locals in a macro.
    - LENGTHOF didn't work if a DB statement contained strings.
    - PUBLIC + EXTERNDEF for the same label caused 2 PUBDEF records to
      be written to the object module.

    Other changes:
    - local labels in procedures supported.
    - '::' operator supported to make a label inside a procedure global.
    - PROTO directive supported.
    - INVOKE supported.
    - TYPEDEF supported.
    - UNION supported.
    - RECORD supported.
    - nested (and anonymous) STRUCTs and UNIONs supported.
    - alignment argument for STRUCT supported.
    - some MASM "options" are accepted:
      + option proc: private | public | export
      + option dotname | nodotname (nodotname is dummy)
      + option casemap:none | notpublic | all  (notpublic is dummy)
      + option prologue: none | prologuedef | <macroname>
      + option epilogue: none | epiloguedef | <macroname>
      + option nokeyword: <reserved_word>
    - FLAT accepted as segment attribute.
    - EXTERNDEF will accept structure names as item's type.
    - /Cp option added to make JWasm preserve case of identifiers.
    - /zcw option added to let JWasm use the Watcom C name mangler.
      (/zcm is the default now).
    - LOW, HIGH, LOWWORD, HIGHWORD, OPATTR, .TYPE, TYPE, WIDTH and MASK
      operators implemented.
    - PROC: procedure parameters and locals are now true symbols with type
      information, internally handled similiar to "structure fields".
      The original approach handled these items as strings, which needs
      an additional "string expansion" step inside procedures and type
      information for such symbols was unavailable for the code generator.
    - LOCAL directive accepts all variations which MASM does.
    - LOCALs may have structured types.
    - PROC parameters may have structured types.
    - STRUCT "redefinitions" accepted (as long as it doesn't change the
      "structure").
    - numeric equates can be contained multiple times in the source as long
      as their values are identical.
    - macro functions and EXITM supported.
    - CATSTR, SUBSTR, SIZESTR and INSTR directives supported.
    - predefined macro functions @CATSTR, @SUBSTR, @SIZESTR, @INSTR supported.
    - ECHO implemented.
    - types REAL4, REAL8 and REAL10 supported.
    - pointer qualifiers NEAR16, NEAR32, FAR16 and FAR32 supported in TYPEDEF.
    - VARARG as macro parameter qualifier supported.
    - .IF, .ELSE, .ELSEIF, .ENDIF, .WHILE, .ENDW, .REPEAT, .UNTIL, .BREAK
      and .CONTINUE implemented.
    - predefined equates @Cpu, @CurSeg, @code, @data, @stack, @Date, @Time,
      @FileName supported.
    - missing conditional directives (ELSEIFB, ELSEIFIDN, ...) implemented.
    - evaluation operator "%" supported.
    - literal character operator "!" supported.
    - cmdline options made more MASM alike (-d1 changed to -Zd, ...).
    - JWasm's -D cmdline option always defines a "text macro", similiar to
      MASM.
    - PURGE implemented.
    - ASSUME <stdreg>:<ptr type> is supported.
    - WHILE implemented.
    - @Environ macro function supported.
    - lots of debug messages added.
    - type PWORD has been removed (was an alias for FWORD).
    - directive DP has been removed (was an alias for DF).
    - directive GLOBAL has been removed (was an alias for EXTERNDEF).
    - support for JMPF/CALLF has been removed.

