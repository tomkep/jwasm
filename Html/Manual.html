<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 FINAL//EN">
<HTML>
<HEAD>
<TITLE> JWasm Manual </TITLE>
</HEAD>
<BODY>
 
<H1 ID="0">    0. Contents </H1>
<DL> 
<DD>    1.    <A HREF="#1">About</A></DD>
<DD>    2.    <A HREF="#2">Commandline Options</A></DD>
<DL>
<DD>          <A HREF="#201">Options -0, -1, -2,  ..., -10</A></DD>
<DD>          <A HREF="#202">Option -bin</A></DD>
<DD>          <A HREF="#203">Option -djgpp</A></DD>
<DD>          <A HREF="#204">Option -elf</A></DD>
<DD>          <A HREF="#205">Option -elf64</A></DD>
<DD>          <A HREF="#206">Option -eq</A></DD>
<DD>          <A HREF="#207">Option -Fd</A></DD>
<DD>          <A HREF="#208">Option -Fw</A></DD>
<DD>          <A HREF="#209">Option -FPi</A></DD>
<DD>          <A HREF="#210">Option -m</A></DD>
<DD>          <A HREF="#211">Option -mz</A></DD>
<DD>          <A HREF="#212">Option -nc</A></DD>
<DD>          <A HREF="#213">Option -nd, -nt</A></DD>
<DD>          <A HREF="#214">Option -nm</A></DD>
<DD>          <A HREF="#215">Option -win64</A></DD>
<DD>          <A HREF="#216">Option -Zd</A></DD>
<DD>          <A HREF="#217">Option -zf</A></DD>
<DD>          <A HREF="#218">Option -Zg</A></DD>
<DD>          <A HREF="#219">Option -Zi</A></DD>
<DD>          <A HREF="#220">Option -zlc, -zld, -zlf and zls</A></DD>
<DD>          <A HREF="#221">Option -Zm</A></DD>
<DD>          <A HREF="#222">Option -Zne</A></DD>
<DD>          <A HREF="#223">Option -zt</A></DD>
<DD>          <A HREF="#224">Option -Zv8</A></DD>
<DD>          <A HREF="#225">Option -zze</A></DD>
<DD>          <A HREF="#226">Option -zzs</A></DD>
</DL>
<DD>    3.    <A HREF="#3">Syntax Extensions</A></DD>
<DL>
<DD>     3.1  <A HREF="#301">Directive INCBIN</A></DD>
<DD>     3.2  <A HREF="#302">FASTCALL Register Calling Convention</A></DD>
<DD>     3.3  <A HREF="#303">IDs enclosed in Back Quotes</A></DD>
<DD>     3.4  <A HREF="#304">Floating-Point Immediates in Instructions</A></DD>
<DD>     3.5  <A HREF="#305">Directive OPTION FIELDALIGN</A></DD>
<DD>     3.6  <A HREF="#306">Directive OPTION PROCALIGN</A></DD>
<DD>     3.7  <A HREF="#307">Directive OPTION MZ</A></DD>
<DD>     3.8  <A HREF="#308">Directive OPTION ELF</A></DD>
<DD>     3.9  <A HREF="#309">Directive OPTION WIN64</A></DD>
<DD>     3.10 <A HREF="#310">Directive OPTION FRAME</A></DD>
<DD>     3.11 <A HREF="#311">Directive OPTION RENAMEKEYWORD</A></DD>
<DD>     3.12 <A HREF="#312">Directive OPTION DLLIMPORT</A></DD>
<DD>     3.13 <A HREF="#313">Directives PUSHCONTEXT / POPCONTEXT ALIGNMENT</A></DD>
<DD>     3.14 <A HREF="#314">Directives .X64 and .X64p</A></DD>
<DD>     3.15 <A HREF="#315">Directive INVOKE in Win64</A></DD>
<DD>     3.16 <A HREF="#316">Attribute LABEL for first Macro Parameter</A></DD>
<DD>     3.17 <A HREF="#317">Member Argument for IF[N]DEF and .ERR[N]DEF</A></DD>
<DD>     3.18 <A HREF="#318">Initialization of Data Items of Type MMWORD/XMMWORD</A></DD>
<DD>     3.19 <A HREF="#319">Other Differences</A></DD>
<DL>
<DD>       a) <A HREF="#3191">Numeric constant __JWASM__</A></DD>
<DD>       b) <A HREF="#3192">Operating System Argument for .MODEL</A></DD>
<DD>       c) <A HREF="#3193">Accepted Parameters for IF[N]DEF Directive</A></DD>
<DD>       d) <A HREF="#3194">Visibility of Procedures</A></DD>
</DL>
</DL>
<DD>    4.    <A HREF="#4">Instruction Sets</A></DD>
<DD>    5.    <A HREF="#5">Code Generation Differences</A></DD>
<DL>
<DD>     5.1  <A HREF="#51">Forward References in Macro Expressions</A></DD>
</DL>
<DD>    6.    <A HREF="#6">Win64 Structured Exception Handling (SEH)</A></DD>
<DD>    7.    <A HREF="#7">Errors and Warnings</A></DD>
<DD>    8.    <A HREF="#8">Masm Bugs fixed in JWasm</A></DD>
<DD>    9.    <A HREF="#9">Known Bugs and missing Features</A></DD>
<DD>    10.   <A HREF="#10">License</A></DD>
<DD>          <A HREF="#AA">Appendix A: Reserved Words</A></DD>
<DD>          <A HREF="#AB">Appendix B: Source Samples</A></DD>
</DL>

<H1 ID="1">    1. About </H1>
 
    This document lists the differences between JWasm and Masm, as far as
    the user interface is concerned.
<P> 
    When Masm is mentioned, then usually Masm v8.00 is meant, unless stated
    otherwise. Masm v8.00 also was the first Masm version supporting 64-bit
    (ML64.EXE).
<P> 
    The Masm documentation itself can be found on numerous places in the web,
    in plain text, HTML, PDF and Windows Help format. However, it's usually
    the documentation that came whith Masm v6.1, hence is a bit outdated.
<P> 

<H1 ID="2">    2. Commandline Options </H1>
 
    Entering 'JWasm -?' or 'JWasm -h' will make JWasm display the options
    it understands. A lot of them exist in both Masm and JWasm, but some
    are valid for JWasm only; OTOH, a few options are missing in JWasm.
<P> 
    Options are usually entered via the command line. Additionally, when
    starting, JWasm will search for environment variable JWASM
    and handle it similar to the way Masm handles variable ML. Hence it is
    also possible to enter options via this method.
<P> 
    The options specific to JWasm - and also the options which are handled
    somewhat differently by JWasm compared to Masm - will be handled in the
    following chapters.

<H2 ID="201">    Options -0, -1, -2,  ..., -10: Select Cpu </H2>
 
    Option [0|1|..|10] selects cpu/instruction set. Most values correspond to
    cpu directives: 
<P>
<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#E8E8E8"><TD> 0</TD><TD>.8086 </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD> 1</TD><TD>.186  </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD> 2</TD><TD>.286  </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD> 3</TD><TD>.386  </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD> 4</TD><TD>.486  </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD> 5</TD><TD>.586  </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD> 6</TD><TD>.686  </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD> 7</TD><TD>.686 and .MMX (P2)</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD> 8</TD><TD>.686, .MMX and SSE instructions (P3)</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD> 9</TD><TD>.686, .MMX, SSE and SSE2 instructions (P4)</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>10</TD><TD>.x64 (x86-64 cpu)</TD></TR>
</TABLE>
</TD></TR>
</TABLE>

<H2 ID="202">    Option -bin: Select Output Format Binary </H2>
 
    Option -bin selects output format BINary. The output module's default file
    extension will be changed from .OBJ to .BIN. The contents of the file
    are just the raw data bytes emitted by the assembler, no header,
    relocations or symbol tables are generated.
<P>
    The binary format is most useful for bootloaders or DOS COM files, but may
    be used to create any binary format. See sample <A HREF="#AB04">Win32_5</A>,
    that demonstrates how to use -bin for creating a Win32 application.
<P>
    If a listing file is produced, a binary map will be added, which shows 
    the file and memory layout of the image:
<PRE> 
                                    .model tiny

                                    .data

00000000  0D0A48656C6C6F2C20    str1    db 13,10,"Hello, world!",13,10,'$'

00000000                            .code

                                    org 100h

00000100                        start:

00000100  B409                      mov ah, 09h
00000102  BA0000                    mov dx, offset str1
00000105  CD21                      int 21h
00000107  B8004C                    mov ax, 4c00h
0000010A  CD21                      int 21h

                                    end start


Binary Map:

Segment                  Pos(file)      VA  Size(fil) Size(mem)
---------------------------------------------------------------
_TEXT                           0      100         C         C
_DATA                           C      10C        12        12
---------------------------------------------------------------
                                                  1E        1E
</PRE>

<H2 ID="203">    Option -djgpp: Select Output Format for DJGPP (optional) </H2>

    Option -djgpp selects Djgpp's variant of COFF as output format. Since it is
    rarely used nowadays, this option isn't activated in the precompiled
    binaries. See <A HREF="#9">9.3c</A> how to enable it.

<H2 ID="204">    Option -elf: Select 32-bit Output Format ELF </H2>

    Option -elf selects output format ELF. JWasm will produce an object module
     in 32-bit Elf format.
<P> 
    Use <A HREF="#308">OPTION ELF</A> to set values in the ELF header.

<H2 ID="205">    Option -elf64: Select 64-bit Output Format ELF </H2>

    Option -elf64 selects output format ELF64. JWasm will produce an object module
    in 64-bit Elf format. Additionally, this option will set cpu to <A HREF="#314">x86-64</A>
    and model to FLAT.
<P> 
    Use <A HREF="#308">OPTION ELF</A> to set values in the ELF header.

<H2 ID="206">    Option -eq: Suppress Error Messages on Screen </H2>

    Option -eq will suppress displaying error messages on the screen. They are still
    written into an error file.

<H2 ID="207">    Option -Fd: Write Import Definitions </H2>

    Option -Fd makes JWasm write import definitions in a format understood by
    Open Watcom's Wlink and JWlink. Such definitions will tell the linker
    how to resolve the external reference; no import library is needed. This
    option is only useful in conjunction with <A HREF="#312">OPTION DLLIMPORT</A> (chapter 3.12).
    Syntax is:
<DL> 
<DD>       -Fd[=file_name]
</DL> 
     If the optional &lt;file_name&gt; argument is given, the import 
     definitions will be written into a file of this name. This is the only
     way for Open Watcom's Wlink to pass the information.
<P>
     If JWlink is used, the &lt;file_name&gt; argument may be omitted. Then
     JWasm will write the import definitions directly into the object module's
     linker directive section (section ".drectve"). This works for output
     formats COFF and ELF only. See sample <A HREF="#AB05">Win32_7</A> how
     to use JWasm and JWlink to create a Windows binary without import libs.

<H2 ID="208">    Option -Fw: Set Error File Name </H2>

    Option -Fw will set the file name for warning and error messages. As default,
    these messages are written to a file with a name equal to the assembly
    source, but with extension .ERR. Syntax is:
<DL> 
<DD>    -Fw file_name
</DL> 
<H2 ID="209">    Option -FPi: Activate Floating-Point Emulation </H2>

    Option -FPi activates "inline FP instructions with emulation". This will make JWasm
    create fixups for floating-point instructions if code is 16bit.
    If supported by the linker or the OS, the FP instructions can then
    be replaced by calls to an FP emulator if no coprocessor exists.

<H2 ID="210">    Option -m: Select Memory Model </H2>

    Option -m generates a line containing a .MODEL directive to
    select a memory model.
    Syntax is:
<DL> 
<DD>    -m[t|s|m|c|l|h|f]
</DL> 
    where the value behind 'm' means:
<DL> 
<DD>    t = tiny
<DD>    s = small
<DD>    m = medium
<DD>    c = compact
<DD>    l = large
<DD>    h = huge
<DD>    f = flat
</DL> 
    This option is ignored if a 64-bit output format (<A HREF="#215">-win64</A> or <A HREF="#205">-elf64</A>)
    is active.

<H2 ID="211">    Option -mz: Select Output Format MZ </H2>

    Option -mz selects output format MZ. This will write a binary in DOS MZ format. The
    module's default file extension will be changed from .OBJ to .EXE. All
    symbols in the module must resolve internally, no externals are allowed.
    Some values in the "MZ" header can be adjusted by directive <A HREF="#307">OPTION MZ</A>
    (see below).

<H2 ID="212">    Option -nc: Set Code Class Name </H2>

    Option -nc sets the code segment's class name if simplified segment
    directives are used (default:CODE). Syntax is:
<DL> 
<DD>    -nc=name
</DL> 
    where &lt;name&gt; will be the code segment's class name.

<H2 ID="213">    Options -nd and -nt: Set DATA and CODE Segment Names </H2>

    Options -nd and -nt will set the name of the data/code segments
    if simplified segment directives are used. Syntax is:
<DL> 
<DD>      -nt=name_of_code
<DD>      -nd=name_of_data
</DL> 
    The default names are _TEXT for code and _DATA for data.

<H2 ID="214">    Option -nm: Set Module Name </H2>

    Option -nm sets the module name. Syntax is:
<DL> 
<DD>     -nm=module_name
</DL> 
    The default value for &lt;module_name&gt; is the name of the source file
    without extension.

<H2 ID="215">    Option -win64: Select Output Format Win64 </H2>

    Option -win64 makes JWasm produce an object module in PE32+ format, 
    the 64-bit format used for Win64 binaries.
<P>
    Option -win64 will also set cpu to <A HREF="#314">x86-64</A>, model to FLAT and
    default calling convention to <A HREF="#302">FASTCALL</A>. This is to make JWasm compatible
    with Masm64 (ML64.EXE).
<P> 
    With <A HREF="#309">OPTION WIN64</A>, parameters specific to Win64 may be set.

<H2 ID="216">    Option -Zd: Emit Line Number Debugging Info </H2>

    Option -Zd generates line number debug information for OMF and COFF output
    format. For other formats, this option is ignored. Line number
    information allows a debugger to trace the binary on the source code
    level. Debuggers which have been verified to work with this option:
    MS CodeView, CDB, WinDbg, MS VC++ EE 2008, OW WD/WDW, PellesC IDE.

<H2 ID="217">    Option -zf: Select FASTCALL Type </H2>

    Option -zf selects the FASTCALL calling convention type
    for 16- and 32-bit code. Syntax is:
<DL> 
<DD>    -zf[0|1]
</DL> 
     The default value 0 is MS VC style, while value 1 activates the Open
     Watcom fastcall type.

<H2 ID="218">    Option -Zg: Masm-compatible Code Generation </H2>

    Option -Zg makes JWasm try an exact copy of Masm's code
     generation, which results in the following changes:
<UL> 
<LI>    the default prologue for procedures will use<br>
        &nbsp;&nbsp;<TT>add [e]sp, - localsize</TT><br>
        instead of<br>
        &nbsp;&nbsp;<TT>sub [e]sp, localsize</TT>.
</LI>
<LI>    the default epilogue for procedures will almost always prefer to 
        generate opcode <TT><b>LEAVE</b></TT> if possible.
</LI>
<LI>    expressions<br>
        &nbsp;&nbsp;<TT>&lt;reg&gt; == 0</TT> and <TT>&lt;reg&gt; != 0</TT><br>
        will generate code<br>
        &nbsp;&nbsp;<TT>or &lt;reg&gt;,&lt;reg&gt;</TT><br>
        instead of<br>
        &nbsp;&nbsp;<TT>cmp &lt;reg&gt;,0</TT>.
</LI>
<LI>    if invoke must extend an argument's size from word to dword,
        register eax remains unchanged.
</LI>
<LI>    the segment value of FAR externals will always be assumed unknown,
        no matter whether the external is defined inside or outside of a 
        segment block. Thus those labels are excluded from "far call
        optimization". 
</LI>
</UL> 

<H2 ID="219">    Option -Zi: Emit Symbolic Debugging Info </H2>

    Option -Zi generates symbolic debugging info in CodeView V4 style for OMF and
    COFF output format. For other formats, this option is accepted, but
    ignored. Debuggers which have been verified to work with this option:
    MS CodeView, CDB, WinDbg, MS VC++ EE 2008, OW WD/WDW, PellesC IDE.

<H2 ID="220">    Options -zlc, -zld, -zlf and -zls: Reduce Size of Output </H2>

    Options -zlc, -zld, -zlf and -zls do reduce size of the output module.
    They might be useful if lots of - small - modules are to be assembled
    and put into a static library. Also, the OMF coment records written
    if -zlc or -zld is NOT set may not be accepted by all linkers.
<P> 
<DL>
<DT>    Option -zlc:</DT>
<DD>    suppresses writing OMF coment records about data in Code segments. 
    This may help a disassembler to produce nicer listings.
<DT>    Option -zld:</DT>
<DD>    suppresses writing an OMF coment record for each Code segment telling the 
    linker that far calls to targets in the same segments should be optimized. 
    This is more or less a feature for 16-bit code only.
<DT>    Option -zlf:</DT>
<DD>    suppresses the @file entry in the COFF symbol table. This entry is
    usually not needed and hence a - pretty small - amount of space is saved.
<DT>    Option -zls:</DT>
<DD>    suppresses the auxiliary entries for sections in the COFF symbol table.
    These entries may not be needed in all cases and thus a little space
    is saved.
</DL>

<H2 ID="221">    Option -Zm: Enable Masm v5 Compatibility </H2>

    Option -Zm (or setting OPTION M510) will do:
<DL>  
<DD>      - set OPTION OLDSTRUCTS
<DD>      - set OPTION DOTNAME
<DD>      - set OPTION SETIF2:TRUE
<DD>      - set OPTION OFFSET:SEGMENT (if no model is set)
<DD>      - set OPTION NOSCOPED (if no model with language specifier is set)
<DD>      - allow to define data items behind code labels
<DD>      - allow "invalid" use of REP/REPE/REPNE instruction prefixes
</DL> 
     Other Masm v5.1 compatibility options aren't implemented yet.

<H2 ID="222">    Option -Zne: Disable JWasm Syntax Extensions </H2>

    Option -Zne will disable syntax extensions which aren't supported
    by Masm. Currently these are:
<DL> 
<DD>      - <A HREF="#301">directive INCBIN</A>
<DD>      - <A HREF="#302">FASTCALL calling convention</A>
<DD>      - <A HREF="#303">IDs enclosed in backquotes</A>
<DD>      - <A HREF="#304">floating-point immediate operands in instructions</A>
<DD>      - directive <A HREF="#305">OPTION FIELDALIGN</A>
<DD>      - directive <A HREF="#306">OPTION PROCALIGN</A>
<DD>      - directive <A HREF="#307">OPTION MZ</A>
<DD>      - directive <A HREF="#308">OPTION ELF</A>
<DD>      - directive <A HREF="#309">OPTION WIN64</A>
<DD>      - directive <A HREF="#311">OPTION RENAMEKEYWORD</A>
<DD>      - directive <A HREF="#312">OPTION DLLIMPORT</A>
<DD>      - directives <A HREF="#313">PUSHCONTEXT / POPCONTEXT ALIGNMENT</A>
<DD>      - <A HREF="#316">attribute LABEL for first macro parameter</A>
<DD>      - <A HREF="#317">member argument for IF[N]DEF and .ERR[N]DEF directives</A>
<DD>      - <A HREF="#318">integer initializer values for items of type [X]MMWORD</A>
<DD>      - name argument for .DATA, .DATA? and .CONST directives
<DD>      - forward references in arguments for INVOKEd procedures
<DD>      - overrides inside square brackets for base/index registers
</DL> 

<H2 ID="223">    Option -zt: Set Name Decoration for STDCALL </H2>

    Option -zt will fine-tune name decoration for STDCALL symbols.
    Syntax is:
<DL> 
<DD>  -zt[0|1|2]
</DL> 
    where value 0 will disable name decoration, value 1 will just add
    an underscore prefix and value 2 - which is the default - will emit
    full STDCALL name decoration as expected by most linkers.
<P>
    Option -zt0 will make object modules compatible to ALINK + Win32.lib.

<H2 ID="224">    Option -Zv8: Enable Masm v8 Procedure Visibility </H2>

    Option -Zv8 changes handling of procedure visibility to the
    way done by Masm v8+. See <A HREF="#3194">Visibility of Procedures</A>
    for details.

<H2 ID="225">    Option -zze: Disable Export Name Decoration </H2>

    Option -zze suppresses name decoration for procedures with
    the EXPORT attribute (exported name only).

<H2 ID="226">    Option -zzs: Avoid Wlink COFF Incompatibility </H2>

    Option -zzs is kind of a workaround for a Wlink incompatibility.
    It's useful to be set if 1) the source module has a starting address,
    2) output format is COFF AND 3) Wlink is to be used as linker.


<H1 ID="3">    3. Syntax Extensions </H1>

    This chapter describes the syntax extensions of JWasm compared to
    Masm v8.

<H2 ID="301">    3.1 Directive INCBIN </H2>
 
    This directive allows to include the contents of a file into
    the object module. Syntax is
<DL> 
<DD>    <font color="#008040">INCBIN filename [, starting offset[, max size]]</font>
</DL> 
    &lt;filename&gt; should be enclosed in &lt;&gt; or double quotes.
<P> 
<P> 
<H2 ID="302">    3.2 FASTCALL Register Calling Convention </H2>

    In <b>16- and 32-bit mode</b>, one may use either the Microsoft or the
    Watcom register calling convention. It's selected by option <A HREF="#217">-zf</A>.
<P> 
    The Microsoft FASTCALL convention uses registers (E)CX and (E)DX for
    the first 2 parameters which are small enough to fit into a register.
<P> 
    The Open Watcom fastcall convention uses up to four registers ( E/AX,
    E/DX, E/BX, E/CX ). 
<P> 
    In <b>64-bit mode</b>, FASTCALL means the standard Windows 64 ABI if option
    <A HREF="#215">-win64</A> was given and it is the default then. For <A HREF="#205">-elf64</A>, there is 
    currently no FASTCALL support.
<P> 
<P> 
<H2 ID="303">    3.3 IDs enclosed in Back Quotes </H2>

    IDs can be enclosed in back quotes (`) and thus they can contain
    characters not allowed in "normal" IDs.
<P> 
<P> 
<H2 ID="304">    3.4 Floating-Point Immediates in Instructions </H2>

    Floating-point immediate values are accepted as instruction operands.
    As default, the type is a REAL4, which has a magnitude of 32 bits:
<pre><font color="#008040"> 
        mov eax, 1.0
</font></pre><P> 
    With type coercion, it's also possible to define a
    64-bit "double", although it's probably useful in 64-bit code only: 
<pre><font color="#008040"> 
        mov rax, real8 ptr 1.0
</font></pre><P> 
    Additionally, operators LOW32 and HIGH32 accept a floating-point constant
    as argument. In this case, the constant is assumed to have format
    REAL8. Thus it's possible to pass a double constant directly as a
    procedure argument in 32-bit code:
<pre><font color="#008040"> 
       push HIGH32 1.0
       push LOW32 1.0
       call WorkWithReal8Value
</font></pre><P> 
<H2 ID="305">    3.5 Directive OPTION FIELDALIGN </H2>

    OPTION FIELDALIGN sets the default value for structure alignment. The
    default value is 1 or the value set by cmdline switch -Zp. Syntax is:
<DL><font color="#008040"> 
<DD>      OPTION FIELDALIGN: [1|2|4|8|16|32]
</DL></font> 
    The current default value can be saved/restored with directives
    <A HREF="#313">PUSHCONTEXT / POPCONTEXT ALIGNMENT</A>,


<H2 ID="306">    3.6 Directive OPTION PROCALIGN </H2>

    With OPTION PROCALIGN parameter it's possible to automatically
    align procedures. Syntax is:
<DL><font color="#008040"> 
<DD>      OPTION PROCALIGN: [1|2|4|8|16|32]
</DL></font> 
    The default value is 1. The current value can be saved/restored with directives
    <A HREF="#313">PUSHCONTEXT / POPCONTEXT ALIGNMENT</A>,
<P>
    Example:
<P><PRE>
    .386
    .model flat, stdcall
    option PROCALIGN:16
    .code

proc1 PROC
    ret
proc1 endp

proc2 PROC
    ret
proc2 endp

    end
</PRE>

<P>The listing shows that start address of <i>proc2</i> is aligned to 16 (=10h):

<P><PRE>
00000000                        proc1 PROC
00000000                            ret
00000000  C3                *   retn
00000001                        proc1 endp

00000010                        proc2 PROC
00000010                            ret
00000010  C3                *   retn
00000011                        proc2 endp
</PRE>

<P>Note: to ensure that the procedures are aligned in the final binary as 
it is supposed by the OPTION PROCALIGN value, the alignment of the current
code segment must be at least the value of OPTION PROCALIGN.

<H2 ID="307">    3.7 Directive OPTION MZ </H2>

    Directive OPTION MZ allows to fine-tune the values written to the
    MZ header if output format MZ (see <A HREF="#211">-mz</A> cmdline option) is selected. For other output formats,
    this option has no effect. The syntax for the directive is:
<DL><font color="#008040"> 
<DD>      OPTION MZ:[start_fixups][:header_align][:heap_min][:heap_max]
</font></DL>
    The parameters are:
<P>
<TABLE cellspacing="4">
<TR><TD VALIGN="top"><i>start_fixups</i></TD><TD>offset within the header where segment fixups will start.
      The size of the header will always be at least this value, even if there
      are no fixups at all. Default - and minimum - value is 1Eh.
</TD></TR>
<TR><TD VALIGN="top"><i>header_align</i></TD><TD>alignment of the header (including segment fixups).
      Value must be a power of 2, 10h is the default and minimum.
</TD></TR>
<TR><TD VALIGN="top"><i>heap_min</i></TD><TD>the additional space (in paragraphs) which is needed by
      the binary to run. Default is the total of the sizes of the
      uninitialized BSS and STACK segments.
</TD></TR>
<TR><TD VALIGN="top"><i>heap_max</i></TD><TD>space (in paragraphs) which the binary would like to have.
      Default is FFFFh.
</TD></TR>
</TABLE>
<P> 
<H2 ID="308">    3.8 Directive OPTION ELF </H2>

    Directive OPTION ELF allows to fine-tune the values written to the
    ELF header if output format ELF (see <A HREF="#204">-elf</A> or <A HREF="#205">-elf64</A>) is selected. For other output formats,
    this option has no effect. The syntax for the directive is:
<DL><font color="#008040"> 
<DD>      OPTION ELF:osabi
</font></DL> 
    The only argument &lt;osabi&gt; will be copied to the ELF header field EI_OSABI.
    It's a numeric constant, and according to the elf specs some valid values are:
<P>
<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#E8E8E8"><TD> 0</TD><TD>ELFOSABI_NONE   </TD><TD>unspecified</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD> 1</TD><TD>ELFOSABI_HPUX   </TD><TD>HP-UX      </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD> 2</TD><TD>ELFOSABI_NETBSD </TD><TD>NetBSD     </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD> 3</TD><TD>ELFOSABI_LINUX  </TD><TD>Linux, <b>default</b></TD></TR>
<TR BGCOLOR="#E8E8E8"><TD> 6</TD><TD>ELFOSABI_SOLARIS</TD><TD>Sun Solaris</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD> 7</TD><TD>ELFOSABI_AIX    </TD><TD>IBM AIX    </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD> 9</TD><TD>ELFOSABI_FREEBSD</TD><TD>FreeBSD    </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>12</TD><TD>ELFOSABI_OPENBSD</TD><TD>OpenBSD    </TD></TR>
</TABLE>
</TD></TR>
</TABLE>
<P> 
<P> 
<H2 ID="309">    3.9 Directive OPTION WIN64 </H2>

    Directive OPTION WIN64 allows to set parameters for the Win64 output
    format if this format (see <A HREF="#215">-win64</A> cmdline option) is selected. For other output formats,
    this option has no effect. The syntax for the directive is:
<DL> <font color="#008040"> 
<DD>      OPTION WIN64: store_register_params
</font></DL> 
<DL>
<DT>    accepted values for <i>store_register_params</i> are:</DT>
<DD>     - 0: Nothing is done, the "home locations" (also sometimes called
          "shadow space") of the first 4 register  parameters are 
          uninitialized. This is the default setting.
<DD>     - 1: register contents of the PROC's first 4 parameters (RCX, RDX, 
          R8 and R9 ) will be copied to the "home locations" within
          a PROC's prologue.
</DL> 
<P>
<H2 ID="310">    3.10 Directive OPTION FRAME </H2>

    This option affects 64-bit only. It allows to make JWasm automatically
    generate prologues and epilogues for procedures with the FRAME attribute.
    Thus the code complies to the rules of <A HREF="#6">Win64 SEH</A> (Structured Exception
    Handling). Syntax is
<DL><font color="#008040"> 
<DD>        OPTION FRAME:&lt;AUTO | NOAUTO&gt;
</font></DL> 
    AUTO will enable this feature, NOAUTO (which is default) disables it.
</P>
    The unwind information which is generated is "complete", that is, it
    contains the ".endprologue" pseudo-op already. To allow to save all
    non-volatile registers in the prologue, the "USES" phrase is more
    capable in this mode and will accept XMM registers to be saved and
    restored.
<P>
<P>
<H2 ID="311">    3.11 Directive OPTION RENAMEKEYWORD </H2>

    This option allows to rename a keyword, so it can be used under a
    different name. Syntax:
<DL><font color="#008040"> 
<DD>       OPTION RENAMEKEYWORD:&lt;current_name&gt;=new_name
</DL></font> 
     <i>current_name</i> is the current name of the keyword and must be
    enclosed in angle brackets. <i>new_name</i> must be a valid identifier.
     If a keyword is to be renamed, it should be done at the beginning
    of the source, and a keyword shouldn't be renamed multiple times.
<P> 

<H2 ID="312">    3.12 Directive OPTION DLLIMPORT </H2>

<H3>    a) Using OPTION DLLIMPORT </H3>

    This option makes the assembler assume that all PROTOs that follow
    this directive represent functions located in a dll. Syntax:
<DL><font color="#008040"> 
<DD>       OPTION DLLIMPORT:&lt;dll_name&gt; | NONE
</font></DL> 
     &lt;dll_name&gt; must be enclosed in angle brackets. Argument NONE
     will switch back to the default mode.
<P> 
    The effects of setting this options are subtle and useful only for 
    MS Windows applications: if the function described by the prototype is
    called via INVOKE, slightly more efficient code than normal is generated,
    because the function's address in the IAT is used. Example:
<DL><font color="#008040"> 
<DD>       INVOKE GetModuleHandle, NULL
</font></DL> 
    code generation with OPTION DLLIMPORT:
<pre><font color="#008040"> 
        push NULL
        call DWORD PTR [_imp__GetModuleHandle@4]
</font></pre> 
    code generation without OPTION DLLIMPORT:
<pre><font color="#008040"> 
        push NULL
        call _GetModuleHandle@4
        ...
    _GetModuleHandle@4:
        jmp DWORD PTR [_imp__GetModuleHandle@4]  ;stub added by the linker
</font></pre> 

<H3>    b) Using OPTION DLLIMPORT in Conjunction with -Fd Switch </H3>

    Optionally, by using cmdline option <A HREF="#207">-Fd</A>, JWasm will write
    the import information received through OPTION DLLIMPORT lines to either
    a file or directly into the object module (COFF and ELF only). Example:
<pre><font color="#008040"> 
        .386
        .model flat,stdcall
        option dllimport:&lt;kernel32&gt;
    GetModuleHandleA proto :dword
    ExitProcess proto :dword
        option dllimport:none
        .code
        invoke GetModuleHandleA, 0
        invoke ExitProcess, 0
        end
</font></pre> 
<DL>
<DD>      JWasm -coff <b>-Fd=lnk.rsp</b> sample.asm
</DL> 
    After the assembly step, file <i>lnk.rsp</i> will contain:
<DL><font color="#008040"> 
<DD>    import '_ExitProcess@4'  kernel32.ExitProcess
<DD>    import '_GetModuleHandleA@4'  kernel32.GetModuleHandleA
</DL></font> 
    Both Open Watcom's Wlink and JWlink will be able to directly use this 
    information and hence, as a result, no further Windows import libraries 
    are needed in the link step:
<DL> 
<DD>      Wlink format windows pe file sample.obj <b>@lnk.rsp</b>
</DL> 
    JWlink may even go one step further - it's able to read import definitions
    contained in a COFF or ELF module's linker directive section ( named
    ".drectve" ). Therefore one can omit the filename argument for -Fd. 
    Sample <A HREF="#AB05">Win32_7</A> demonstrates the usage.
<P> 
<H2 ID="313">    3.13 Directives PUSHCONTEXT / POPCONTEXT ALIGNMENT </H2>

    The PUSHCONTEXT / POPCONTEXT directives understand new qualifier
    ALIGNMENT, which saves/restores current values of <A HREF="#305">FIELDALIGN</A> and
    <A HREF="#306">PROCALIGN</A> options.


<H2 ID="314">    3.14 Directives .X64 and .X64p </H2>

    These directives select a 64-bit (x86-64) cpu.
    In contrast to .X64, .X64p will allow to use privileged instructions.
<P>
    The .X64 directive isn't needed usually, because for output formats WIN64
    (see <A HREF="#215">-win64</A>) and ELF64 (see <A HREF="#205">-elf64</A>),
    .X64 is the default.
<P>
    The .X64p directive is useful for mixed-model binaries or system software (see example <A HREF="#AB03">DOS64</A> ).
<P>
     When the cpu is set to 64-bit, the SEGMENT directive accepts a new
    'size' value: USE64. It tells the assembler that this segment's offset
    is 64-bit wide and uses 64-bit instructions.
<P>
     The SYSCALL calling convention is renamed to SYSCALL_ when 64-bit is on,
    because there exists a SYSCALL instruction mnemonic in this mode.


<H2 ID="315">    3.15 Directive INVOKE in Win64 </H2>

    The 64-bit version of Masm doesn't support INVOKE anymore. JWasm still
    does, but please be aware of some restrictions:
<DL>
<DD>    - in theory, using INVOKE requires the FRAME attribute for PROC. It will
      work without FRAME, but Win64 SEH won't be happy with it then.
<DD>    - the implementation in 64-bit is very simple: for each INVOKE register
      RSP is reduced by the space required for the arguments, then the call 
      is issued and finally register RSP is restored.
<DD>    - there is no additional check that the stack is aligned to 16 byte. The
      PROC's FRAME attribute ensures that the stack is correctly aligned after
      the prologue is done. However, it's the programmers responsibility that
      the stack is still aligned when the code generated by INVOKE starts.
</DL> 

<H2 ID="316">    3.16 Attribute LABEL for first Macro Parameter </H2>

    The LABEL attribute for the first macro parameter allows access to a
    label which is assigned to the macro. Syntax is:
<P> <font color="#008040"> 
    &lt;macro_name&gt; MACRO &lt;param_name&gt;:LABEL [,&lt;param_name&gt;[, ...]]
<P> </font> 
    The LABEL attribute is accepted for the first parameter only. A macro
    with such a parameter can be invoked in the following way:
<P> <font color="#008040"> 
    &lt;label&gt; &lt;macro_name&gt; [&lt;argument&gt;, ...]
<P> </font> 
    Example:
<P> <pre><font color="#008040"> 
    foo macro lbl:LABEL, first, second
    lbl  db first
         dw second
    endm

    .data

    data1 foo 1,1000
    data2 foo 2,2000
<P></font></pre> 

<H2 ID="317">    3.17 Member Argument for IF[N]DEF and .ERR[N]DEF Directives </H2>

    Since v2.07, JWasm's implementation of IF[N]DEF - and .ERR[N]DEF - will
    additionally accept a struct member as argument. This syntax requires
    a fully qualified name:
<P><pre><font color="#008040"> 
      IFDEF &lt;struct_name&gt;.&lt;member_name&gt;
<P></font></pre> 
<P> 
<H2 ID="318">    3.18 Initialization of Data Items with Type MMWORD/XMMWORD </H2>

    For data items of types MMWORD or XMMWORD, JWasm will accept integer
    values for initialization:
<P><pre><font color="#008040"> 
    vmm1  MMWORD  1122334455667788h
    vxmm1 XMMWORD 112233445566778899AABBCCDDEEFFh
<P></font></pre> 
    Masm will accept just floating-point initializers for data items of
    type [X]MMWORD. It's even worse, since floating-point initializers are
    <b>silently</b> ignored for data items with  sizes != 4, 8 and 10; since
    XMMWORD has size 16, it's impossible to initialize such an item directly.
    JWasm copies this Masm behavior, but to allow to initialize a XMMWORD 
    with a floating-point value, one may use type coercion:
<P><pre><font color="#008040"> 
    vxmm1 XMMWORD real4 ptr 1.0   ;bytes 4-15 will be 0
    vxmm2 XMMWORD real8 ptr 1.0   ;bytes 8-15 will be 0
<P></font></pre> 
    Variants that work in both JWasm and Masm, and also allow to
    initialize the full XMMWORD are:
<P><pre><font color="#008040"> 
    vxmm1 LABEL XMMWORD
      real4 1.0, 2.0, 3.0, 4.0
    vxmm2 LABEL XMMWORD
      real8 1.0, 2.0
<P></font></pre> 
<P>
<P>
<H2 ID="319">    3.19 Other Differences </H2>

<H3 ID="3191">    a) Numeric constant __JWASM__ </H3>

    __JWASM__ is a predefined symbol, its value is the current JWasm
    version * 100, that is, for v1.9 the value is 190. The predefined text
    equate @Version won't contain JWasm's version, for compatibility reasons
    it has value &lt;800&gt; (since v2.06, previously the value was &lt;615&gt;).

<H3 ID="3192">    b) Operating System Argument for .MODEL </H3>

    The .MODEL directive has an optional "operating system" argument. Masm
    accepts value OS_DOS only, JWasm accepts values OS_DOS and OS_OS2.
    This setting will affect the generated code of directives .STARTUP and
    .EXIT for 16-bit memory models.

<H3 ID="3193">    c) Accepted Parameters for IF[N]DEF Directive </H3>

    Masm's IF[N]DEF directive accepts user-defined symbols and registers,
    but fails for instructions, directives and other reserved words. JWasm's
    IF[N}DEF implementation accepts those symbols as well. OTOH, JWasm is
    a bit more picky and will display a warning if more than one item is 
    found behind the directive - Masm just takes the first and silently skips
    the rest.
<P>
    Also see <A HREF="#317">Member Argument for IF[N]DEF and .ERR[N]DEF Directives</A>.

<H3 ID="3194">    d) Visibility of Procedures </H3>

    When a PROTO or EXTERNDEF directive for a symbol is located in a module
    before a matching PROC directive, the visibility of this Procedure 
    ( "public" vs "private", or "external" vs. "static" ) is handled 
    differently in Masm v6 or 7 and Masm v8 or newer:
<P> 
    Since Masm v8, a PROTO or EXTERNDEF for a symbol which is later defined
    as a PROC will make the procedure public, no matter what a possible
    visibility attribute of the PROC itself - or the default one set with 
    OPTION PROC - is telling.
<P> 
    OTOH, with Masm v6/7, both the visibility attribute of the PROC directive
    and the current default setting of OPTION PROC will affect ths symbol's
    visibility.
<pre >
                Masm6 Masm8 JWasm JWasm+Zv8
      -------------------------------------
      On,E,P            x             x
      On,E,Pn           x             x
      On,E,Pp     x     x      x      x
      Op,E,P      x     x      x      x
      Op,E,Pn     x     x             x
      Op,E,Pp     x     x      x      x

      On = OPTION PROC:PRIVATE
      Op = OPTION PROC:PUBLIC
      E  = PROTO or EXTERNDEF before PROC
      P  = PROC without visibility attribute
      Pn = PROC with PRIVATE visibility attribute
      Pp = PROC with PUBLIC visibility attribute
      x  = procedure will be public
</pre> 
    As default, JWasm more or less copies the Masm v6/7 behavior. The
    difference is that an explicite visibility attribute behind PROC has 
    the highest priority for JWasm. However, since v2.04, there's an 
    additional cmdline option -Zv8 which will make JWasm behave like Masm v8+.
<P> 
    It should be noted that without a PROTO/EXTERNDEF before PROC, there
    are no differences between Masm v6, v8 and JWasm, and the -Zv8 switch
    also has no effect then.
<P> 
<P> 
<H1 ID="4">    4. Instruction Sets </H1>

    JWasm supports all instructions sets supported by Masm v8. These are
<P> 
<DL>
<DD>    - the instructions implemented by 8086, 80186, 80286, 80386, 80486.
<DD>    - the Pentium and Pentium Pro instructions.
<DD>    - the MMX and K3D instruction set extensions.
<DD>    - the SSE, SSE2, SSE3 and SSSE3 instruction set extensions.
<DD>    - the x86-64 64-bit instruction set (implemented by ML64).
</DL> 
    Since JWasm v2.01, instruction sets SSE4.1 and SSE4.2 are supported.
    ( With Masm, these instructions require Masm v9 ).
<P> 
    Since JWasm v2.06, instruction set AVX is supported.
    ( With Masm, these instructions require Masm v10 ).
<P> 
<P> 
<H1 ID="5">    5. Code Generation Differences </H1>

    JWasm might generate slightly different code than Masm on some occasions.
    Commandline option <A HREF="#218">-Zg</A> should eliminate most of these differences.
    However, some differences are due to fixed Masm bugs (see below), in
    which case option -Zg won't have any effect.
<P>
    For a few instructions, the encoding differs between Masm versions.
<P> Example:
<PRE><font color="#008040">    cmp al,dl
<P></font></PRE>
    is encoded <TT>38 D0</TT> in Masm v6, but <TT>3A C2</TT> in Masm v8.
    In such cases, JWasm will prefer to copy the encoding of Masm v8. 

<H2 ID="51">    5.1 Forward References in Macro Expressions </H2>

    Like Masm, JWasm usually evaluates expressions in preprocessor directives
    during the first pass only. However, due to different jump optimization
    strategies of Masm and JWasm, the results may differ. This is very
    unlikely to impose a problem, but it is mentioned here for completeness.
    An example (found in README.TXT of Masm v6.14):
<P><pre><font color="#008040"> 
      Label1:
           JMP Label2
      Label2:

      REPEAT Label2 - Label1
           INC AX
      ENDM
<P></font></pre> 
    Masm will - incorrectly - repeat the loop 10 times, although the result
    of expression <TT>Label2 - Label1</TT> is 2 only. OTOH, JWasm will repeat the 
    loop 2 times only, because it's using an "optimistic" strategy concerning
    forward references.
<P> 
<P> 
<H1 ID="6">    6. Win64 Structured Exception Handling (SEH) </H1>

    SEH in Win64 differs significantly from the implementation in Win32.
    It's very well possible to ignore Win64 SEH for assembly. However,
    if an assembly routine wants to comply to these rules, a thorough
    understanding of the Win64 ABI is necessary. Masm ( the 64-bit
    version ) supplies some "primitives" for SEH support (.ALLOCSTACK,
    .PUSHREG, .SAVEREG, ...), along with a new FRAME attribute for the
    PROC directive. These features are also supported by JWasm. See sample
    <A HREF="#AB01">Win64_3</A> how the "primitives" are to be used for SEH support.
<P>
    The big disadvantage is that using the FRAME keyword in Masm "disables"
    most of the other high level features combined with PROC (function 
    parameters, locals and registers saved with USES) because no function
    prologues and epilogues are generated anymore. Additionally, the 
    implementation in some Masm versions seems to be a bit buggy.
    Because of this and to ease the usage of SEH in Win64 there is a new 
    directive implemented in JWasm:
<PRE><font color="#008040"> 
        <A HREF="#310">OPTION FRAME:AUTO</A>
</font></PRE><P> 
    If this option is set, JWasm will create Win64 SEH-compatible prologues
    and epilogues. If the option is off, JWasm will behave Masm-compatible,
    that is, FRAME found in a PROC directive will disable automatic 
    prologue/epilogue generation. See sample <A HREF="#AB02">Win64_3e</A> how this option
    is supposed to be used.
<P> 
    As for the PROC syntax: The Masm documentation states that FRAME can be
    used in combination with USES and procedure parameters and must be
    located behind all parameters. However, this syntax isn't accepted by
    any Masm version. The only syntax which Masm will accept without being
    confused is FRAME as the one and only parameter for PROC. Therefore
    JWasm doesn't follow the Masm documentation in this point: the optional
    FRAME keyword is expected *before* the procedure parameters. The syntax
    in JWasm is:
<P><pre><font color="#008040"> 
    procname PROC [public] FRAME[:exc_handler] [USES &lt;reglist&gt;] [parameters]
<P></font></pre> 
    The SEH "primitives" will generate some additional data in segments
    .pdata and .xdata. This data is somewhat hidden, but JWasm will display
    the corresponding data definitions in the listing if option -Sg is set.
<P> 
<H1 ID="7">    7. Errors and Warnings </H1>

    The warning and error numbers emitted by JWasm differ from Masm's.
    However, the texts of the messages are pretty much identical. There
    are a few messages which deserve a more detailed explanation:
<DL> 
<DD>    - '<b>Text macro was used before definition</b>': this is a warning only. 
    However, using text macros before they have been defined will force
    JWasm to do a full second pass, which increases assembly time.
<P>
<DD>    - '<b>IF[n]DEF expects a plain symbol as argument</b>': this is a warning.
    Masm accepts any expression as argument for directives [ELSE]IF[N]DEF, but
    the result probably isn't always what has been expected. 
<P>
<DD>    - '<b>Size not specified, assuming: &lt;type&gt;</b>': this is a warning.
    &lt;type&gt; may be BYTE, WORD or DWORD. The message may occur if an
	immediate value is written to an untyped memory reference:
<P><pre><font color="#008040"> 
       mov [ebx], 1
<P></font></pre> 
    JWasm makes a guess and displays the warning, while Masm will display an
    error in such cases.
</DL> 
<P> 
<H1 ID="8">    8. Masm bugs fixed in JWasm </H1>
<DL> 
<DD>    - the infamous "invoke" bug: using invoke with variables of type BYTE
      (or WORD in 32bit code) causes bad code to be generated in Masm.
<DD>    - PROTOs contained twice in the source caused an EXTDEF entry to be
      generated in the object module.
<DD>    - "TYPE xmm0" will return 10 in Masm v6 and v7, JWasm returns 16, same
      as Masm v8.
<DD>    - a nested structure might cause a GPF in Masm if the embedded STRUCT's
      starting offset has to be adjusted due to alignment.
<DD>    - defining huge arrays in Masm is very slow and might even cause a
      deadlock if COFF has been selected as output format.
<DD>    - for Masm v6 and v7, if an array > 64 kB is defined and output
      format OMF is selected, the array's size will be mod 0x10000 only.
<DD>    - Masm doesn't flag invalid numbers in struct/array initializer strings.
<DD>    - if an ALIAS is defined somewhere in the source and the symbol table
      is listed, a 'General Failure' error occurs in Masm if output format
      is OMF.
<DD>    - Type "coerces" for DWORD data items defined in a 32bit segment are
      ignored by Masm, i.e., "dd far16 ptr &lt;symbol&gt;" will generate a
      near32 fixup instead of a far16 one.
<DD>    - if the ALIGN directive has to add 5 bytes in 32bit code segments,
      Masm includes an "add eax,0" opcode, which isn't a no-op because
      flags are modified.
<DD>    - silent truncation of immediate constants: Masm v6 and v7 will accept
      line "mov [word_variable],12345h" without error.
<DD>    - preprocessed output with option -EP may erroneously contain text
      macros and macro function calls if the macros are located in the
      initialization string of a structured variable.
<DD>    - Masm generates wrong code if a conditional jump is coupled with a
      type coercion which modifies offset magnitude. Examples: "jz near32
      ptr ..." in 16bit code or "jz near16 ptr ..." in 32bit code).
<DD>    - if the arguments given to Masm end with an option which expects
      a parameter (i.e. "ml -c -Fo"), a 'General Failure' may occur.
<DD>    - floating-point data items in Masm can be followed by any suffix
      (example: REAL4 1.0foo, 2.0bar). JWasm won't accept this.
<DD>    - If a local is defined inside a macro, Masm will create a unique name
      for it. The name is constructed by using '??' as prefix, followed by
      a hexadecimal number with 4 digits. There is no check for overflow,
      however, so if the total of locals in all macros exceeds 65536,
      strange errors will occur.
</DL> 
    It's slightly dangerous to fix old Masm bugs, since some code might
    work only if the bugs exists. So no, JWasm won't achieve 100% Masm
    compatibility.
<P> 
<P> 
<H1 ID="9">    9. Known Bugs and missing Features </H1>

<H2>    a) Bugs which are known but not fixed yet: </H2>

    There are currently no known bugs.

<H2>    b) Features which aren't implemented yet: </H2>
<DL> 
<DD>    - directives PAGE, TITLE, SUBTITLE, SUBTTL.
      the directives are ignored and a warning (level 3) is displayed.
<DD>    - the following parameters of the OPTION directive:
<DL>
<DD>      - OLDMACROS
<DD>      - EXPR16
<DD>      - READONLY
</DL>
<DD>    - optional parameter NONUNIQUE for structures is ignored.
<DD>    - commandline option -Zd for ELF output format.
<DD>    - commandline option -Zi for ELF output format.
</DL> 
<H2>    c) Features which aren't active in the precompiled binaries: </H2>
<DL> 
<DD>    - support for Djgpp's variant of COFF. [ -DDJGPP_SUPPORT ]
</DL> 
    You'll have to recompile the sources with the appropriate macros
    defined ( see the values within [] above ) to enable these features. 

<H2>    d) Missing features which most likely won't be implemented: </H2>
<DL> 
<DD>    - %OUT directive
<DD>    - syntax "mm(n)" and "xmm(n)" (supported by Masm v6 and v7 only)
</DL> 

<H1 ID="10">    10. License </H1>

<P> This manual was written by Andreas Grech ( aka Japheth ).
<P> It may be redistributed as long as it is free of charge.

<H1 ID="AA"> Appendix A: JWasm Reserved Words </H1>

Reserved Words are case-insensitive. Besides the items listed below all
instruction mnemonics are also Reserved Words.

<H2>Registers 16- and 32-bit Modes</H2>

<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#F0F0F0">
<TD>8-bit registers</TD>
<TD>AL</TD>
<TD>CL</TD>
<TD>DL</TD>  
<TD>BL</TD>  
<TD>AH</TD>  
<TD>CH</TD>  
<TD>DH</TD>  
<TD>BH</TD>  
</TR>
<TR BGCOLOR="#ECECEC">
<TD>16-bit registers</TD>
<TD>AX</TD>    
<TD>CX</TD>    
<TD>DX</TD>    
<TD>BX</TD>    
<TD>SP</TD>    
<TD>BP</TD>    
<TD>SI</TD>    
<TD>DI</TD>    
</TR>
<TR BGCOLOR="#E8E8E8">
<TD>32-bit registers</TD>
<TD>EAX</TD>    
<TD>ECX</TD> 
<TD>EDX</TD> 
<TD>EBX</TD> 
<TD>ESP</TD> 
<TD>EBP</TD> 
<TD>ESI</TD> 
<TD>EDI</TD> 
</TR>
<TR BGCOLOR="#F0F0E8">
<TD>Segment registers</TD>
<TD>ES  </TD> 
<TD>CS  </TD> 
<TD>SS  </TD> 
<TD>DS  </TD> 
<TD>FS  </TD> 
<TD>GS  </TD> 
<TD> </TD> 
<TD> </TD> 
</TR>
<TR BGCOLOR="#F0E8F0">
<TD>Floating-point registers</TD>
<TD>ST  </TD> 
<TD>ST(1)</TD> 
<TD>ST(2)</TD> 
<TD>ST(3)</TD> 
<TD>ST(4)</TD> 
<TD>ST(5)</TD> 
<TD>ST(6)</TD> 
<TD>ST(7)</TD> 
</TR>
<TR BGCOLOR="#E8F0F0">
<TD>MMX registers</TD>
<TD>MM0 </TD> 
<TD>MM1 </TD> 
<TD>MM2 </TD> 
<TD>MM3 </TD> 
<TD>MM4 </TD> 
<TD>MM5 </TD> 
<TD>MM6 </TD> 
<TD>MM7 </TD> 
</TR>
<TR BGCOLOR="#E0F0F0">
<TD>SSE registers</TD>
<TD>XMM0 </TD> 
<TD>XMM1 </TD> 
<TD>XMM2 </TD> 
<TD>XMM3 </TD> 
<TD>XMM4 </TD> 
<TD>XMM5 </TD> 
<TD>XMM6 </TD> 
<TD>XMM7 </TD> 
</TR>
<TR BGCOLOR="#D8F0F0">
<TD>AVX registers</TD>
<TD>YMM0 </TD> 
<TD>YMM1 </TD> 
<TD>YMM2 </TD> 
<TD>YMM3 </TD> 
<TD>YMM4 </TD> 
<TD>YMM5 </TD> 
<TD>YMM6 </TD> 
<TD>YMM7 </TD> 
</TR>
<TR BGCOLOR="#F0E0E0">
<TD>Control registers</TD>
<TD>CR0 </TD> 
<TD> </TD> 
<TD>CR2 </TD> 
<TD>CR3 </TD> 
<TD>CR4 </TD> 
<TD> </TD> 
<TD> </TD> 
<TD> </TD> 
</TR>
<TR BGCOLOR="#F0F0E0">
<TD>Debug registers</TD>
<TD>DR0 </TD> 
<TD>DR1 </TD> 
<TD>DR2 </TD> 
<TD>DR3 </TD> 
<TD> </TD> 
<TD> </TD> 
<TD>DR6 </TD> 
<TD>DR7 </TD> 
</TR>
<TR BGCOLOR="#E0E0F0">
<TD>Trace registers</TD>
<TD> </TD> 
<TD> </TD> 
<TD> </TD> 
<TD>TR3 </TD> 
<TD>TR4 </TD> 
<TD>TR5 </TD> 
<TD>TR6 </TD> 
<TD>TR7 </TD>
</TR>
</TABLE>
</TD></TR>
</TABLE>

<H2>Additional Registers in 64-bit Mode</H2

<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#F0F0F0">
<TD>8-bit registers</TD>
<TD> </TD> 
<TD> </TD> 
<TD> </TD> 
<TD> </TD> 
<TD>SPL </TD> 
<TD>BPL </TD> 
<TD>SIL </TD> 
<TD>DIL </TD> 
</TR>
<TR BGCOLOR="#F0F0F0">
<TD></TD>
<TD>R8B </TD> 
<TD>R9B </TD> 
<TD>R10B</TD> 
<TD>R11B</TD> 
<TD>R12B</TD> 
<TD>R13B</TD> 
<TD>R14B</TD> 
<TD>R15B</TD>
</TR>
<TR BGCOLOR="#ECECEC">
<TD>16-bit registers</TD>
<TD>R8W  </TD> 
<TD>R9W  </TD> 
<TD>R10W </TD> 
<TD>R11W </TD> 
<TD>R12W </TD> 
<TD>R13W </TD> 
<TD>R14W </TD> 
<TD>R15W </TD> 
</TR>
<TR BGCOLOR="#E8E8E8">
<TD>32-bit registers</TD>
<TD>R8D  </TD> 
<TD>R9D  </TD> 
<TD>R10D </TD> 
<TD>R11D </TD> 
<TD>R12D </TD> 
<TD>R13D </TD> 
<TD>R14D </TD> 
<TD>R15D </TD> 
</TR>
<TR BGCOLOR="#E4E4E4">
<TD>64-bit registers</TD>
<TD>RAX  </TD> 
<TD>RCX  </TD> 
<TD>RDX  </TD> 
<TD>RBX  </TD> 
<TD>RSP  </TD> 
<TD>RBP  </TD> 
<TD>RSI  </TD> 
<TD>RDI  </TD> 
</TR>
<TR BGCOLOR="#E4E4E4">
<TD></TD>
<TD>R8   </TD> 
<TD>R9   </TD> 
<TD>R10  </TD> 
<TD>R11  </TD> 
<TD>R12  </TD> 
<TD>R13  </TD> 
<TD>R14  </TD> 
<TD>R15  </TD> 
</TR>
<TR BGCOLOR="#E0F0F0">
<TD>SSE registers</TD>
<TD>XMM8     </TD> 
<TD>XMM9     </TD> 
<TD>XMM10    </TD> 
<TD>XMM11    </TD> 
<TD>XMM12    </TD> 
<TD>XMM13    </TD> 
<TD>XMM14    </TD> 
<TD>XMM15    </TD> 
</TR>
<TR BGCOLOR="#D8F0F0">
<TD>AVX registers</TD>
<TD>YMM8     </TD> 
<TD>YMM9     </TD> 
<TD>YMM10    </TD> 
<TD>YMM11    </TD> 
<TD>YMM12    </TD> 
<TD>YMM13    </TD> 
<TD>YMM14    </TD> 
<TD>YMM15    </TD> 
</TR>
<TR BGCOLOR="#F0E0E0">
<TD>Control registers</TD>
<TD>CR8</TD>
<TD> </TD> 
<TD> </TD> 
<TD> </TD> 
<TD> </TD> 
<TD> </TD> 
<TD> </TD> 
<TD> </TD> 
</TR>
</TABLE>
</TD></TR>
</TABLE>

<H2>Types</H2>

<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#D8D8DC"><TD>BYTE   </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>SBYTE  </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>WORD   </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>SWORD  </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>DWORD  </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>SDWORD </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>REAL4  </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>FWORD  </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>QWORD  </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>SQWORD </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>REAL8  </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>TBYTE  </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>REAL10 </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>OWORD  </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>YMMWORD</TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>NEAR   </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>FAR    </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>NEAR16 </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>NEAR32 </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>FAR16  </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>FAR32  </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>MMWORD </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>XMMWORD</TD></TR>
</TABLE>
</TD></TR>
</TABLE>

<H2>Unary Operators</H2>

<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#D8DCDC"><TD>.TYPE      </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>HIGH       </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>HIGH32     </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>HIGHWORD   </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>IMAGEREL<sup>[1]</sup></TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>LENGTH     </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>LENGTHOF   </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>LOW        </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>LOW32      </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>LOWWORD    </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>LROFFSET   </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>MASK       </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>OFFSET     </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>OPATTR     </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>SECTIONREL<sup>[1]</sup></TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>SEG        </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>SHORT      </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>SIZE       </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>SIZEOF     </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>THIS       </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>TYPE       </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>WIDTH      </TD></TR>
</TABLE>
</TD></TR>
</TABLE>
[1]: not for OMF output format.

<H2>Binary Operators</H2>

<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#DCDCD8"><TD>EQ  </TD></TR>
<TR BGCOLOR="#DCDCD8"><TD>NE  </TD></TR>
<TR BGCOLOR="#DCDCD8"><TD>GE  </TD></TR>
<TR BGCOLOR="#DCDCD8"><TD>GT  </TD></TR>
<TR BGCOLOR="#DCDCD8"><TD>LE  </TD></TR>
<TR BGCOLOR="#DCDCD8"><TD>LT  </TD></TR>
<TR BGCOLOR="#DCDCD8"><TD>MOD </TD></TR>
<TR BGCOLOR="#DCDCD8"><TD>PTR </TD></TR>
<TR BGCOLOR="#DCDCD8"><TD>DUP </TD></TR>
</TABLE>
</TD></TR>
</TABLE>

<H2>Directives</H2>

<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#D8F0D8"><TD>.8086  </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.186   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.286   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.286C  </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.286P  </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.386   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.386C  </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.386P  </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.486   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.486P  </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.586   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.586P  </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.686   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.686P  </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.K3D   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.MMX   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.XMM   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.X64   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.X64P  </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.8087  </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.287   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.387   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.NO87  </TD></TR> 

<TR BGCOLOR="#D0E8D8"><TD>.CREF        </TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.LFCOND      </TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.LIST        </TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.LISTALL     </TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.LISTIF      </TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.NOCREF      </TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.NOLIST      </TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.NOLISTIF    </TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.SFCOND      </TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.TFCOND      </TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.XCREF       </TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.XLIST       </TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>PAGE         </TD></TR>    
<TR BGCOLOR="#D0E8D8"><TD>SUBTITLE     </TD></TR>    
<TR BGCOLOR="#D0E8D8"><TD>SUBTTL       </TD></TR>    
<TR BGCOLOR="#D0E8D8"><TD>TITLE        </TD></TR>    
<TR BGCOLOR="#D0E8D8"><TD>.LISTMACRO   </TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.LISTMACROALL</TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.NOLISTMACRO </TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.XALL        </TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.LALL        </TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.SALL        </TD></TR> 

<TR BGCOLOR="#D4F0D4"><TD>.ALPHA       </TD></TR> 
<TR BGCOLOR="#D4F0D4"><TD>.DOSSEG      </TD></TR> 
<TR BGCOLOR="#D4F0D4"><TD>.SEQ         </TD></TR> 
<TR BGCOLOR="#D4F0D4"><TD>DOSSEG       </TD></TR>  

<TR BGCOLOR="#D4F4D8"><TD>.CODE        </TD></TR> 
<TR BGCOLOR="#D4F4D8"><TD>.STACK       </TD></TR> 
<TR BGCOLOR="#D4F4D8"><TD>.DATA        </TD></TR> 
<TR BGCOLOR="#D4F4D8"><TD>.DATA?       </TD></TR> 
<TR BGCOLOR="#D4F4D8"><TD>.FARDATA     </TD></TR> 
<TR BGCOLOR="#D4F4D8"><TD>.FARDATA?    </TD></TR> 
<TR BGCOLOR="#D4F4D8"><TD>.CONST       </TD></TR> 

<TR BGCOLOR="#D8F0D0"><TD>.IF          </TD></TR> 
<TR BGCOLOR="#D8F0D0"><TD>.REPEAT      </TD></TR> 
<TR BGCOLOR="#D8F0D0"><TD>.WHILE       </TD></TR> 
<TR BGCOLOR="#D8F0D0"><TD>.BREAK       </TD></TR> 
<TR BGCOLOR="#D8F0D0"><TD>.CONTINUE    </TD></TR> 
<TR BGCOLOR="#D8F0D0"><TD>.ELSE        </TD></TR> 
<TR BGCOLOR="#D8F0D0"><TD>.ELSEIF      </TD></TR> 
<TR BGCOLOR="#D8F0D0"><TD>.ENDIF       </TD></TR> 
<TR BGCOLOR="#D8F0D0"><TD>.ENDW        </TD></TR> 
<TR BGCOLOR="#D8F0D0"><TD>.UNTIL       </TD></TR> 
<TR BGCOLOR="#D8F0D0"><TD>.UNTILCXZ    </TD></TR> 

<TR BGCOLOR="#D0F0D8"><TD>.EXIT        </TD></TR> 
<TR BGCOLOR="#D0F0D8"><TD>.STARTUP     </TD></TR> 
<TR BGCOLOR="#D0F0D8"><TD>.MODEL       </TD></TR> 
<TR BGCOLOR="#D0F0D8"><TD>.RADIX       </TD></TR> 
<TR BGCOLOR="#D0F0D8"><TD>.SAFESEH     </TD></TR> 

<TR BGCOLOR="#D8F0D8"><TD>.ERR         </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERR1        </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERR2        </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERRE        </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERRNZ       </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERRDIF      </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERRDIFI     </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERRIDN      </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERRIDNI     </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERRB        </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERRNB       </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERRDEF      </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERRNDEF     </TD></TR> 

<TR BGCOLOR="#D8F8D8"><TD>COMMENT      </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IF           </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IFE          </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IF1          </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IF2          </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IFDIF        </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IFDIFI       </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IFIDN        </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IFIDNI       </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IFB          </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IFNB         </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IFDEF        </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IFNDEF       </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSE         </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIF       </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIFE      </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIF1      </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIF2      </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIFDIF    </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIFDIFI   </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIFIDN    </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIFIDNI   </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIFB      </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIFNB     </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIFDEF    </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIFNDEF   </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ENDIF        </TD></TR> 

<TR BGCOLOR="#C8F0D8"><TD>FOR          </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>FORC         </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>IRP          </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>IRPC         </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>REPEAT       </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>REPT         </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>WHILE        </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>MACRO        </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>EXITM        </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>ENDM         </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>GOTO         </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>PURGE        </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>INCLUDE      </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>TEXTEQU      </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>CATSTR       </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>SUBSTR       </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>INSTR        </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>SIZESTR      </TD></TR> 

<TR BGCOLOR="#D8F0C8"><TD>DB           </TD></TR> 
<TR BGCOLOR="#D8F0C8"><TD>DW           </TD></TR> 
<TR BGCOLOR="#D8F0C8"><TD>DD           </TD></TR> 
<TR BGCOLOR="#D8F0C8"><TD>DF           </TD></TR> 
<TR BGCOLOR="#D8F0C8"><TD>DQ           </TD></TR> 
<TR BGCOLOR="#D8F0C8"><TD>DT           </TD></TR> 

<TR BGCOLOR="#D8F0DC"><TD>STRUC        </TD></TR> 
<TR BGCOLOR="#D8F0DC"><TD>STRUCT       </TD></TR> 
<TR BGCOLOR="#D8F0DC"><TD>UNION        </TD></TR> 
<TR BGCOLOR="#D8F0DC"><TD>TYPEDEF      </TD></TR> 
<TR BGCOLOR="#D8F0DC"><TD>RECORD       </TD></TR> 

<TR BGCOLOR="#D8E8D8"><TD>COMM         </TD></TR> 
<TR BGCOLOR="#D8E8D8"><TD>EXTERN       </TD></TR> 
<TR BGCOLOR="#D8E8D8"><TD>EXTRN        </TD></TR> 
<TR BGCOLOR="#D8E8D8"><TD>EXTERNDEF    </TD></TR> 
<TR BGCOLOR="#D8E8D8"><TD>PUBLIC       </TD></TR> 
<TR BGCOLOR="#D8E8D8"><TD>PROTO        </TD></TR> 

<TR BGCOLOR="#D4F0D8"><TD>PROC         </TD></TR> 
<TR BGCOLOR="#D4F0D8"><TD>ENDP         </TD></TR> 
<TR BGCOLOR="#D4F0D8"><TD>LOCAL        </TD></TR> 
<TR BGCOLOR="#D4F0D8"><TD>LABEL        </TD></TR> 
<TR BGCOLOR="#D4F0D8"><TD>INVOKE       </TD></TR> 

<TR BGCOLOR="#D8F0DC"><TD>ORG          </TD></TR> 
<TR BGCOLOR="#D8F0DC"><TD>ALIGN        </TD></TR> 
<TR BGCOLOR="#D8F0DC"><TD>EVEN         </TD></TR> 

<TR BGCOLOR="#C8F0D8"><TD>SEGMENT      </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>ENDS         </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>GROUP        </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>ASSUME       </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>ALIAS        </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>ECHO         </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>END          </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>EQU          </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>INCBIN       </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>INCLUDELIB   </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>NAME         </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>OPTION       </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>POPCONTEXT   </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>PUSHCONTEXT  </TD></TR> 
</TABLE>
</TD></TR>
</TABLE>

<H2>Additional Directives in 64-bit Mode</H2>

<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#D8E0D8"><TD>.ALLOCSTACK  </TD></TR> 
<TR BGCOLOR="#D8E0D8"><TD>.ENDPROLOG   </TD></TR> 
<TR BGCOLOR="#D8E0D8"><TD>.PUSHFRAME   </TD></TR> 
<TR BGCOLOR="#D8E0D8"><TD>.PUSHREG     </TD></TR> 
<TR BGCOLOR="#D8E0D8"><TD>.SAVEREG     </TD></TR> 
<TR BGCOLOR="#D8E0D8"><TD>.SAVEXMM128  </TD></TR> 
<TR BGCOLOR="#D8E0D8"><TD>.SETFRAME    </TD></TR> 
</TABLE>
</TD></TR>
</TABLE>

<H2>Other Reserved Words</H2>

<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#ECECD8"><TD>ADDR   </TD></TR>
<TR BGCOLOR="#ECECD8"><TD>FLAT   </TD></TR>
<TR BGCOLOR="#ECECD8"><TD>VARARG </TD></TR>
<TR BGCOLOR="#ECECD8"><TD>FRAME<sup>[1]</sup>  </TD></TR>
<TR BGCOLOR="#ECE8D0"><TD>C       </TD></TR> 
<TR BGCOLOR="#ECE8D0"><TD>SYSCALL<sup>[2]</sup> </TD></TR> 
<TR BGCOLOR="#ECE8D0"><TD>STDCALL </TD></TR> 
<TR BGCOLOR="#ECE8D0"><TD>PASCAL  </TD></TR> 
<TR BGCOLOR="#ECE8D0"><TD>FORTRAN </TD></TR> 
<TR BGCOLOR="#ECE8D0"><TD>BASIC   </TD></TR> 
<TR BGCOLOR="#ECE8D0"><TD>FASTCALL</TD></TR> 
</TABLE>
</TD></TR>
</TABLE>
[1]: in 64-bit mode only.<br>
[2]: in 64-bit, calling convention SYSCALL is renamed to SYSCALL_, since
in this mode there exists a SYSCALL instruction.<br>



<H1 ID="AB"> Appendix B: Source Samples </H1>

<DL>
<DD>   <A HREF="#AB01">Win64_3 - SEH Support in Win64</A></DD>
<DD>   <A HREF="#AB02">Win64_3e - SEH Support in Win64 (JWasm specific)</A></DD>
<DD>   <A HREF="#AB03">DOS64 - Switch to Long Mode and Back</A></DD>
<DD>   <A HREF="#AB04">Win32_5 - Create a Win32 Binary with -bin</A></DD>
<DD>   <A HREF="#AB05">Win32_7 - Usage of OPTION DLLIMPORT and -Fd Switch</A></DD>
</DL>

<H2 ID="AB01"> Win64_3 - SEH Support in Win64 </H1>

<TABLE BORDER=0 CELLSPACING=4 CELLPADDING=4 WIDTH="100%">
<TR BGCOLOR=#E0E0E0><TD>
<pre>

;<font color=#808080>--- This sample shows how to use SEH primitives. It doesn't use hll</font>
;<font color=#808080>--- directives. Thus this source can be assembled by both JWasm </font>
;<font color=#808080>--- and Masm64.</font>
;<font color=#808080>---</font>
;<font color=#808080>--- to assemble enter:</font>
;<font color=#808080>---   JWasm -win64 Win64_3.asm</font>
;<font color=#808080>--- or:</font>
;<font color=#808080>---   ml64 -c Win64_3.asm</font>
;<font color=#808080>---</font>
;<font color=#808080>--- to link the binary enter:</font>
;<font color=#808080>---   Link Win64_3.obj</font>

    <b>option</b> casemap:none

    <b>includelib</b> kernel32.lib
    <b>includelib</b> user32.lib

HINSTANCE <b>typedef</b> QWORD
HWND      <b>typedef</b> QWORD
HMENU     <b>typedef</b> QWORD
HICON     <b>typedef</b> QWORD
HBRUSH    <b>typedef</b> QWORD
HCURSOR   <b>typedef</b> QWORD
WPARAM    <b>typedef</b> QWORD
LPARAM    <b>typedef</b> QWORD
LPSTR     <b>typedef</b> QWORD
LPVOID    <b>typedef</b> QWORD
UINT      <b>typedef</b> DWORD

NULL           <b>equ</b> 0
WS_OVERLAPPEDWINDOW <b>equ</b> 0CF0000h
CW_USEDEFAULT  <b>equ</b> 80000000h
SW_SHOWDEFAULT <b>equ</b> 10
SW_SHOWNORMAL  <b>equ</b> 1
IDC_ARROW      <b>equ</b> 32512
IDI_APPLICATION <b>equ</b> 32512
WM_DESTROY     <b>equ</b> 2
CS_VREDRAW     <b>equ</b> 1
CS_HREDRAW     <b>equ</b> 2
COLOR_WINDOW   <b>equ</b> 5

proto_WNDPROC <b>typedef</b> proto :HWND,:QWORD,:WPARAM,:LPARAM
WNDPROC <b>typedef</b> ptr proto_WNDPROC

WNDCLASSEXA <b>struct</b> 8
cbSize          DWORD   ?
style           DWORD   ?
lpfnWndProc     WNDPROC ?
cbClsExtra      DWORD   ?
cbWndExtra      DWORD   ?
hInstance       HINSTANCE ?
hIcon           HICON   ?
hCursor         HCURSOR ?
hbrBackground   HBRUSH  ?
lpszMenuName    LPSTR   ?
lpszClassName   LPSTR   ?
hIconSm         HICON   ?
WNDCLASSEXA <b>ends</b>

POINT   <b>struct</b>
x   SDWORD  ?
y   SDWORD  ?
POINT   <b>ends</b>

MSG <b>struct</b> 8
hwnd    HWND    ?
message DWORD   ?
wParam  WPARAM  ?
lParam  LPARAM  ?
time    DWORD   ?
pt      POINT   &lt;&gt;
MSG <b>ends</b>

GetModuleHandleA <b>proto</b> :LPSTR
GetCommandLineA  <b>proto</b>
ExitProcess      <b>proto</b> :UINT
LoadIconA        <b>proto</b> :HINSTANCE, :LPSTR
LoadCursorA      <b>proto</b> :HINSTANCE, :LPSTR
RegisterClassExA <b>proto</b> :ptr WNDCLASSEXA
CreateWindowExA  <b>proto</b> :DWORD, :LPSTR, :LPSTR, :DWORD, :SDWORD, :SDWORD, :SDWORD, :SDWORD, :HWND, :HMENU, :HINSTANCE, :LPVOID
ShowWindow       <b>proto</b> :HWND, :SDWORD
UpdateWindow     <b>proto</b> :HWND
GetMessageA      <b>proto</b> :ptr MSG, :HWND, :SDWORD, :SDWORD
TranslateMessage <b>proto</b> :ptr MSG
DispatchMessageA <b>proto</b> :ptr MSG
PostQuitMessage  <b>proto</b> :SDWORD
DefWindowProcA   <b>proto</b> :HWND, :UINT, :WPARAM, :LPARAM

;<font color=#808080>WinMain proto :HINSTANCE, :HINSTANCE, :LPSTR, :UINT</font>

    <b>.data</b>

ClassName <b>db</b> "SimpleWinClass",0
AppName  <b>db</b> "Our First Window",0

    <b>.data?</b>

hInstance HINSTANCE ?
CommandLine LPSTR ?

    <b>.code</b>

WinMainCRTStartup <b>proc</b> FRAME
    <font color=#0000E0>push</font>   rbp
    <b>.pushreg</b> rbp
    <font color=#0000E0>mov</font>    rbp,rsp
    <b>.setframe</b> rbp, 0
    <b>.endprolog</b>

    <font color=#0000E0>sub</font>    rsp,32
    <font color=#0000E0>mov</font>    ecx,NULL
    <font color=#0000E0>call</font>   GetModuleHandleA
    <font color=#0000E0>mov</font>    hInstance, rax
    <font color=#0000E0>call</font>   GetCommandLineA
    <font color=#0000E0>mov</font>    CommandLine, rax
    <font color=#0000E0>mov</font>    rcx, hInstance
    <font color=#0000E0>mov</font>    rdx, NULL
    <font color=#0000E0>mov</font>    r8, CommandLine
    <font color=#0000E0>mov</font>    r9d, SW_SHOWDEFAULT
    <font color=#0000E0>call</font>   WinMain
    <font color=#0000E0>mov</font>    ecx, eax
    <font color=#0000E0>call</font>   ExitProcess
    <b>align</b> 4
WinMainCRTStartup <b>endp</b>

WinMain <b>proc</b> FRAME

    <font color=#0000E0>push</font>  rbp
    <b>.pushreg</b> rbp
    <font color=#0000E0>mov</font>   rbp,rsp
    <b>.setframe</b> rbp, 0
    <b>.endprolog</b>
    <font color=#0000E0>sub</font>   rsp, sizeof WNDCLASSEXA + sizeof MSG + sizeof HWND + 12*8

hInst     <b>equ</b> &lt;[rbp+10h]&gt;
hPrevInst <b>equ</b> &lt;[rbp+18h]&gt;
CmdLine   <b>equ</b> &lt;[rbp+20h]&gt;
CmdShow   <b>equ</b> &lt;[rbp+28h]&gt;

wc   <b>equ</b> &lt;[rbp - sizeof WNDCLASSEXA].WNDCLASSEXA&gt;
msg  <b>equ</b> &lt;[rbp - sizeof WNDCLASSEXA - sizeof MSG].MSG&gt;
hwnd <b>equ</b> &lt;[rbp - sizeof WNDCLASSEXA - sizeof MSG - sizeof HWND]&gt;

    <font color=#0000E0>mov</font>   hInst, rcx  ;<font color=#808080>store param1 in shadow space</font>

    <font color=#0000E0>mov</font>   wc.cbSize, SIZEOF WNDCLASSEXA
    <font color=#0000E0>mov</font>   wc.style, CS_HREDRAW <font color=#0000E0>or</font> CS_VREDRAW
;<font color=#808080>   mov   rax, OFFSET WndProc  ;using LEA is preferable</font>
    <font color=#0000E0>lea</font>   rax, [WndProc]
    <font color=#0000E0>mov</font>   wc.lpfnWndProc, rax
    <font color=#0000E0>mov</font>   wc.cbClsExtra, NULL
    <font color=#0000E0>mov</font>   wc.cbWndExtra, NULL
    <font color=#0000E0>mov</font>   wc.hInstance, rcx
    <font color=#0000E0>mov</font>   wc.hbrBackground, COLOR_WINDOW+1
    <font color=#0000E0>mov</font>   wc.lpszMenuName, NULL
;<font color=#808080>    mov   rax, OFFSET ClassName  ;using LEA is preferable</font>
    <font color=#0000E0>lea</font>   rax, [ClassName]
    <font color=#0000E0>mov</font>   wc.lpszClassName, rax
    <font color=#0000E0>mov</font>   ecx, NULL
    <font color=#0000E0>mov</font>   edx, IDI_APPLICATION
    <font color=#0000E0>call</font>  LoadIconA
    <font color=#0000E0>mov</font>   wc.hIcon, rax
    <font color=#0000E0>mov</font>   wc.hIconSm, rax
    <font color=#0000E0>mov</font>   ecx, NULL
    <font color=#0000E0>mov</font>   edx, IDC_ARROW
    <font color=#0000E0>call</font>  LoadCursorA
    <font color=#0000E0>mov</font>   wc.hCursor,rax
    <font color=#0000E0>lea</font>   rcx, wc
    <font color=#0000E0>call</font>  RegisterClassExA
    <font color=#0000E0>mov</font>   ecx, NULL
    <font color=#0000E0>lea</font>   rdx, [ClassName]
    <font color=#0000E0>lea</font>   r8, [AppName]
    <font color=#0000E0>mov</font>   r9d, WS_OVERLAPPEDWINDOW
    <font color=#0000E0>mov</font>   dword ptr [rsp+4*8], CW_USEDEFAULT
    <font color=#0000E0>mov</font>   dword ptr [rsp+5*8], CW_USEDEFAULT
    <font color=#0000E0>mov</font>   dword ptr [rsp+6*8], CW_USEDEFAULT
    <font color=#0000E0>mov</font>   dword ptr [rsp+7*8], CW_USEDEFAULT
    <font color=#0000E0>mov</font>   qword ptr [rsp+8*8], NULL
    <font color=#0000E0>mov</font>   qword ptr [rsp+9*8], NULL
    <font color=#0000E0>mov</font>   rax, hInst
    <font color=#0000E0>mov</font>   [rsp+10*8], rax
    <font color=#0000E0>mov</font>   qword ptr [rsp+11*8], NULL
    <font color=#0000E0>call</font>  CreateWindowExA
    <font color=#0000E0>mov</font>   hwnd,rax
    <font color=#0000E0>mov</font>   rcx, hwnd
    <font color=#0000E0>mov</font>   edx, SW_SHOWNORMAL
    <font color=#0000E0>call</font>  ShowWindow
    <font color=#0000E0>mov</font>   rcx, hwnd
    <font color=#0000E0>call</font>  UpdateWindow
;<font color=#808080>--- message loop</font>
@@:
        <font color=#0000E0>lea</font> rcx, msg
        <font color=#0000E0>mov</font> rdx, NULL
        <font color=#0000E0>mov</font> r8, 0
        <font color=#0000E0>mov</font> r9, 0
        <font color=#0000E0>call</font> GetMessageA
        <font color=#0000E0>and</font> rax, rax
        <font color=#0000E0>jz</font> @F
        <font color=#0000E0>lea</font> rcx, msg
        <font color=#0000E0>call</font> TranslateMessage
        <font color=#0000E0>lea</font> rcx, msg
        <font color=#0000E0>call</font> DispatchMessageA
        jmp @B
@@:
    <font color=#0000E0>mov</font>   rax, msg.wParam
    <font color=#0000E0>add</font>   rsp, sizeof WNDCLASSEXA + sizeof MSG + sizeof HWND + 12*8
    <font color=#0000E0>pop</font>   rbp
    <font color=#0000E0>ret</font>
    <b>align</b> 4
WinMain <b>endp</b>

WndProc <b>proc</b> FRAME

    <font color=#0000E0>sub</font>   rsp, 4*8
    <b>.allocstack</b> 4*8
    <b>.endprolog</b>

    <font color=#0000E0>cmp</font> edx, WM_DESTROY
    <font color=#0000E0>jnz</font> @F
    <font color=#0000E0>mov</font> ecx, NULL
    <font color=#0000E0>call</font> PostQuitMessage
    <font color=#0000E0>xor</font> rax,rax
    jmp exit
@@:
    <font color=#0000E0>call</font> DefWindowProcA
exit:
    <font color=#0000E0>add</font> rsp, 4*8
    <font color=#0000E0>ret</font>
    <b>align</b> 4
WndProc <b>endp</b>

<b>end</b>
</pre>
</TD></TR>
</TABLE>

<H2 ID="AB02"> Win64_3e - SEH Support in Win64 (JWasm specific) </H1>

<TABLE BORDER=0 CELLSPACING="4" CELLPADDING="4">
<TR BGCOLOR=#E0E0E0><TD>
<pre>

;<font color=#808080>--- SEH support in Win64. Unlike Win64_3, </font>
;<font color=#808080>--- this version uses hll directives, so it cannot be assembled</font>
;<font color=#808080>--- with Masm64. Also, OPTION FRAME:AUTO is used.</font>
;<font color=#808080>---</font>
;<font color=#808080>--- to create the binary enter:</font>
;<font color=#808080>---   JWasm -win64 Win64_3e.asm</font>
;<font color=#808080>---   Link Win64_3e.obj</font>

    <b>option</b> casemap:none
    <b>option</b> frame:auto    ;<font color=#808080>generate SEH-compatible prologues and epilogues</font>

    <b>includelib</b> kernel32.lib
    <b>includelib</b> user32.lib

HINSTANCE <b>typedef</b> QWORD
HWND      <b>typedef</b> QWORD
HMENU     <b>typedef</b> QWORD
HICON     <b>typedef</b> QWORD
HBRUSH    <b>typedef</b> QWORD
HCURSOR   <b>typedef</b> QWORD
WPARAM    <b>typedef</b> QWORD
LPARAM    <b>typedef</b> QWORD
LPSTR     <b>typedef</b> QWORD
LPVOID    <b>typedef</b> QWORD
UINT      <b>typedef</b> DWORD

NULL           <b>equ</b> 0
WS_OVERLAPPEDWINDOW <b>equ</b> 0CF0000h
CW_USEDEFAULT  <b>equ</b> 80000000h
SW_SHOWDEFAULT <b>equ</b> 10
SW_SHOWNORMAL  <b>equ</b> 1
IDC_ARROW      <b>equ</b> 32512
IDI_APPLICATION <b>equ</b> 32512
WM_DESTROY     <b>equ</b> 2
CS_VREDRAW     <b>equ</b> 1
CS_HREDRAW     <b>equ</b> 2
COLOR_WINDOW   <b>equ</b> 5

proto_WNDPROC <b>typedef</b> proto :HWND,:QWORD,:WPARAM,:LPARAM
WNDPROC <b>typedef</b> ptr proto_WNDPROC

WNDCLASSEXA <b>struct</b> 8
cbSize          DWORD   ?
style           DWORD   ?
lpfnWndProc     WNDPROC ?
cbClsExtra      DWORD   ?
cbWndExtra      DWORD   ?
hInstance       HINSTANCE ?
hIcon           HICON   ?
hCursor         HCURSOR ?
hbrBackground   HBRUSH  ?
lpszMenuName    LPSTR   ?
lpszClassName   LPSTR   ?
hIconSm         HICON   ?
WNDCLASSEXA <b>ends</b>

POINT   <b>struct</b>
x   SDWORD  ?
y   SDWORD  ?
POINT   <b>ends</b>

MSG <b>struct</b> 8
hwnd    HWND    ?
message DWORD   ?
wParam  WPARAM  ?
lParam  LPARAM  ?
time    DWORD   ?
pt      POINT   &lt;&gt;
MSG <b>ends</b>

GetModuleHandleA <b>proto</b> :LPSTR
GetCommandLineA  <b>proto</b>
ExitProcess      <b>proto</b> :UINT
LoadIconA        <b>proto</b> :HINSTANCE, :LPSTR
LoadCursorA      <b>proto</b> :HINSTANCE, :LPSTR
RegisterClassExA <b>proto</b> :ptr WNDCLASSEXA
CreateWindowExA  <b>proto</b> :DWORD, :LPSTR, :LPSTR, :DWORD, :SDWORD, :SDWORD, :SDWORD, :SDWORD, :HWND, :HMENU, :HINSTANCE, :LPVOID
ShowWindow       <b>proto</b> :HWND, :SDWORD
UpdateWindow     <b>proto</b> :HWND
GetMessageA      <b>proto</b> :ptr MSG, :HWND, :SDWORD, :SDWORD
TranslateMessage <b>proto</b> :ptr MSG
DispatchMessageA <b>proto</b> :ptr MSG
PostQuitMessage  <b>proto</b> :SDWORD
DefWindowProcA   <b>proto</b> :HWND, :UINT, :WPARAM, :LPARAM

WinMain <b>proto</b> :HINSTANCE, :HINSTANCE, :LPSTR, :UINT

    <b>.data</b>

ClassName <b>db</b> "SimpleWinClass",0
AppName  <b>db</b> "Our First Window",0

    <b>.data?</b>

hInstance HINSTANCE ?
CommandLine LPSTR ?

    <b>.code</b>

WinMainCRTStartup <b>proc</b> FRAME

    <b>invoke</b> GetModuleHandleA, NULL
    <font color=#0000E0>mov</font>    hInstance, rax
    <b>invoke</b> GetCommandLineA
    <font color=#0000E0>mov</font>    CommandLine, rax
    <b>invoke</b> WinMain, hInstance, NULL, CommandLine, SW_SHOWDEFAULT
    <b>invoke</b> ExitProcess, eax

WinMainCRTStartup <b>endp</b>

WinMain <b>proc</b> FRAME hInst:HINSTANCE, hPrevInst:HINSTANCE, CmdLine:LPSTR, CmdShow:UINT

    <b>local</b> wc:WNDCLASSEXA
    <b>local</b> msg:MSG
    <b>local</b> hwnd:HWND

    <font color=#0000E0>mov</font>   hInst, rcx
    <font color=#0000E0>mov</font>   wc.cbSize, SIZEOF WNDCLASSEXA
    <font color=#0000E0>mov</font>   wc.style, CS_HREDRAW <font color=#0000E0>or</font> CS_VREDRAW
    <font color=#0000E0>lea</font>   rax, [WndProc]
    <font color=#0000E0>mov</font>   wc.lpfnWndProc, rax
    <font color=#0000E0>mov</font>   wc.cbClsExtra, NULL
    <font color=#0000E0>mov</font>   wc.cbWndExtra, NULL
    <font color=#0000E0>mov</font>   wc.hInstance, rcx
    <font color=#0000E0>mov</font>   wc.hbrBackground, COLOR_WINDOW+1
    <font color=#0000E0>mov</font>   wc.lpszMenuName, NULL
    <font color=#0000E0>lea</font>   rax, [ClassName]
    <font color=#0000E0>mov</font>   wc.lpszClassName, rax
    <b>invoke</b> LoadIconA, NULL, IDI_APPLICATION
    <font color=#0000E0>mov</font>   wc.hIcon, rax
    <font color=#0000E0>mov</font>   wc.hIconSm, rax
    <b>invoke</b> LoadCursorA, NULL, IDC_ARROW
    <font color=#0000E0>mov</font>   wc.hCursor,rax
    <b>invoke</b> RegisterClassExA, addr wc
    <b>invoke</b> CreateWindowExA, NULL, ADDR ClassName, ADDR AppName,\
           WS_OVERLAPPEDWINDOW, CW_USEDEFAULT,\
           CW_USEDEFAULT, CW_USEDEFAULT,CW_USEDEFAULT, NULL, NULL,\
           hInst, NULL
    <font color=#0000E0>mov</font>   hwnd,rax
    <b>invoke</b> ShowWindow, hwnd, SW_SHOWNORMAL
    <b>invoke</b> UpdateWindow, hwnd
    <b>.while</b> (1)
        <b>invoke</b> GetMessageA, ADDR msg, NULL, 0, 0
        <b>.break</b> .if (!rax)
        <b>invoke</b> TranslateMessage, ADDR msg
        <b>invoke</b> DispatchMessageA, ADDR msg
    <b>.endw</b>
    <font color=#0000E0>mov</font>   rax, msg.wParam
    <font color=#0000E0>ret</font>
WinMain <b>endp</b>

WndProc <b>proc</b> FRAME hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM

    <b>.if</b> ( edx == WM_DESTROY )
        <b>invoke</b> PostQuitMessage, NULL
        <font color=#0000E0>xor</font> rax,rax
    <b>.else</b>
        <b>invoke</b> DefWindowProcA, rcx, edx, r8, r9
    <b>.endif</b>
    <font color=#0000E0>ret</font>
WndProc <b>endp</b>

<b>end</b> WinMainCRTStartup
</pre>
</TD></TR>
</TABLE>

<H2 ID="AB03"> DOS64 - Switch to Long Mode and Back </H1>

<TABLE BORDER=0 CELLSPACING=4 CELLPADDING=4 WIDTH="100%">
<TR BGCOLOR=#E0E0E0><TD>
<pre>

;<font color=#808080>--- DOS program which switches to long-mode and back.</font>
;<font color=#808080>--- Note: requires at least JWasm v2.</font>
;<font color=#808080>--- Also: needs a 64bit cpu in real-mode to run.</font>
;<font color=#808080>--- Parts of the source are based on samples supplied by</font>
;<font color=#808080>--- sinsi and Tomasz Grysztar in the FASM forum.</font>
;<font color=#808080>--- To create the binary enter:</font>
;<font color=#808080>---  JWasm -mz DOS64.asm</font>

    <b>.x64p</b>

;<font color=#808080>--- 16bit start/exit code</font>

_TEXT16 <b>segment</b> use16 para public 'CODE'

    <b>assume</b> ds:_TEXT16
    <b>assume</b> es:_TEXT16

GDTR <b>label</b> fword        ;<font color=#808080> Global Descriptors Table Register</font>
    <b>dw</b> 4*8-1            ;<font color=#808080> limit of GDT (size minus one)</font>
    <b>dd</b> offset GDT       ;<font color=#808080> linear address of GDT</font>
IDTR <b>label</b> fword        ;<font color=#808080> Interrupt Descriptor Table Register</font>
    <b>dw</b> 256*16-1         ;<font color=#808080> limit of IDT (size minus one)</font>
    <b>dd</b> 0                ;<font color=#808080> linear address of IDT</font>
nullidt <b>label</b> fword
    <b>dw</b> 3FFh
    <b>dd</b> 0
  
    <b>align</b> 8
GDT <b>dq</b> 0                    ;<font color=#808080> null desciptor</font>
    <b>dw</b> 0FFFFh,0,9A00h,0AFh  ;<font color=#808080> 64-bit code descriptor</font>
    <b>dw</b> 0FFFFh,0,9A00h,000h  ;<font color=#808080> compatibility mode code descriptor</font>
    <b>dw</b> 0FFFFh,0,9200h,000h  ;<font color=#808080> compatibility mode data descriptor</font>

wPICMask <b>dw</b> 0   ;<font color=#808080> variable to save/restore PIC masks</font>

start16:
    <font color=#0000E0>push</font> cs
    <font color=#0000E0>pop</font> ds
    <font color=#0000E0>mov</font> ax,cs
    <font color=#0000E0>movzx</font> eax,ax
    <font color=#0000E0>shl</font> eax,4
    <font color=#0000E0>add</font> dword ptr [GDTR+2], eax ;<font color=#808080> convert offset to linear address</font>
    <font color=#0000E0>mov</font> word ptr [GDT+2*8+2], ax
    <font color=#0000E0>mov</font> word ptr [GDT+3*8+2], ax
    <font color=#0000E0>shr</font> eax,16
    <font color=#0000E0>mov</font> byte ptr [GDT+2*8+4], al
    <font color=#0000E0>mov</font> byte ptr [GDT+3*8+4], al

    <font color=#0000E0>mov</font> ax,ss
    <font color=#0000E0>mov</font> dx,es
    <font color=#0000E0>sub</font> ax,dx
    <font color=#0000E0>mov</font> bx,sp
    <font color=#0000E0>shr</font> bx,4
    <font color=#0000E0>add</font> bx,ax
    <font color=#0000E0>mov</font> ah,4Ah
    <font color=#0000E0>int</font> 21h         ;<font color=#808080> free unused memory</font>
    <font color=#0000E0>push</font> cs
    <font color=#0000E0>pop</font> es
    <font color=#0000E0>mov</font> ax,ss
    <font color=#0000E0>mov</font> dx,cs
    <font color=#0000E0>sub</font> ax,dx
    <font color=#0000E0>shl</font> ax,4
    <font color=#0000E0>add</font> ax,sp
    <font color=#0000E0>push</font> ds
    <font color=#0000E0>pop</font> ss
    <font color=#0000E0>mov</font> sp,ax       ;<font color=#808080> make a TINY model, CS=SS=DS=ES</font>

    <font color=#0000E0>smsw</font> ax
    <font color=#0000E0>test</font> al,1
    <font color=#0000E0>jz</font> @F
    <font color=#0000E0>mov</font> dx,offset err1
    <font color=#0000E0>mov</font> ah,9
    <font color=#0000E0>int</font> 21h
    <font color=#0000E0>mov</font> ah,4Ch
    <font color=#0000E0>int</font> 21h
err1 <b>db</b> "Mode is V86. Need REAL mode to switch to LONG mode!",13,10,'$'
@@:
    <font color=#0000E0>xor</font> edx,edx
    <font color=#0000E0>mov</font> eax,80000001h   ;<font color=#808080> test if long-mode is supported</font>
    <font color=#0000E0>cpuid</font>
    <font color=#0000E0>test</font> edx,20000000h
    <font color=#0000E0>jnz</font> @F
    <font color=#0000E0>mov</font> dx,offset err2
    <font color=#0000E0>mov</font> ah,9
    <font color=#0000E0>int</font> 21h
    <font color=#0000E0>mov</font> ah,4Ch
    <font color=#0000E0>int</font> 21h
err2 <b>db</b> "No 64bit cpu detected.",13,10,'$'
@@:
    <font color=#0000E0>mov</font> bx,1000h
    <font color=#0000E0>mov</font> ah,48h
    <font color=#0000E0>int</font> 21h
    <font color=#0000E0>jnc</font> @F
    <font color=#0000E0>mov</font> dx,offset err3
    <font color=#0000E0>mov</font> ah,9
    <font color=#0000E0>int</font> 21h
    <font color=#0000E0>mov</font> ah,4Ch
    <font color=#0000E0>int</font> 21h
err3 <b>db</b> "Out of memory",13,10,'$'
@@:
    <font color=#0000E0>add</font> ax,100h-1   ;<font color=#808080> align to page boundary</font>
    <font color=#0000E0>mov</font> al,0
    <font color=#0000E0>mov</font> es,ax

;<font color=#808080>--- setup page directories and tables</font>

    <font color=#0000E0>sub</font> di,di
    <font color=#0000E0>mov</font> cx,4096
    <font color=#0000E0>sub</font> eax,eax
    <font color=#0000E0>rep</font> <font color=#0000E0>stosd</font>       ;<font color=#808080> clear 4 pages</font>

    <font color=#0000E0>sub</font> di,di
    <font color=#0000E0>mov</font> ax,es
    <font color=#0000E0>movzx</font> eax,ax
    <font color=#0000E0>shl</font> eax,4
    <font color=#0000E0>mov</font> cr3,eax             ;<font color=#808080> load page-map level-4 base</font>

    <font color=#0000E0>lea</font> edx, [eax+5000h]
    <font color=#0000E0>mov</font> dword ptr [IDTR+2], edx

    <font color=#0000E0>or</font> eax,111b
    <font color=#0000E0>add</font> eax, 1000h
    <font color=#0000E0>mov</font> es:[di+0000h],eax   ;<font color=#808080> first PDP table</font>
    <font color=#0000E0>add</font> eax, 1000h
    <font color=#0000E0>mov</font> es:[di+1000h],eax   ;<font color=#808080> first page directory</font>
    <font color=#0000E0>add</font> eax, 1000h
    <font color=#0000E0>mov</font> es:[di+2000h],eax   ;<font color=#808080> first page table</font>
    <font color=#0000E0>mov</font> di,3000h            ;<font color=#808080> address of first page table</font>
    <font color=#0000E0>mov</font> eax,0 + 111b
    <font color=#0000E0>mov</font> cx,256              ;<font color=#808080> number of pages to map (1 MB)</font>
@@:
    <font color=#0000E0>stosd</font>
    <font color=#0000E0>add</font> di,4
    <font color=#0000E0>add</font> eax,1000h
    <font color=#0000E0>loop</font> @B

;<font color=#808080>--- setup ebx/rbx with linear address of _TEXT</font>

    <font color=#0000E0>mov</font> bx,_TEXT
    <font color=#0000E0>movzx</font> ebx,bx
    <font color=#0000E0>shl</font> ebx,4
    <font color=#0000E0>add</font> [llg], ebx

;<font color=#808080>--- create IDT</font>

    <font color=#0000E0>mov</font> di,5000h
    <font color=#0000E0>mov</font> cx,32
    <font color=#0000E0>mov</font> edx, offset exception
    <font color=#0000E0>add</font> edx, ebx
make_exc_gates:
    <font color=#0000E0>mov</font> eax,edx
    <font color=#0000E0>stosw</font>
    <font color=#0000E0>mov</font> ax,8
    <font color=#0000E0>stosw</font>
    <font color=#0000E0>mov</font> ax,8E00h
    <font color=#0000E0>stosd</font>
    <font color=#0000E0>xor</font> eax, eax
    <font color=#0000E0>stosd</font>
    <font color=#0000E0>stosd</font>
    <font color=#0000E0>add</font> edx,4
    <font color=#0000E0>loop</font> make_exc_gates
    <font color=#0000E0>mov</font> cx,256-32
make_int_gates:
    <font color=#0000E0>mov</font> eax,offset interrupt
    <font color=#0000E0>add</font> eax, ebx
    <font color=#0000E0>stosw</font>
    <font color=#0000E0>mov</font> ax,8
    <font color=#0000E0>stosw</font>
    <font color=#0000E0>mov</font> ax,8E00h
    <font color=#0000E0>stosd</font>
    <font color=#0000E0>xor</font> eax, eax
    <font color=#0000E0>stosd</font>
    <font color=#0000E0>stosd</font>
    <font color=#0000E0>loop</font> make_int_gates

    <font color=#0000E0>mov</font> di,5000h
    <font color=#0000E0>mov</font> eax, ebx
    <font color=#0000E0>add</font> eax, offset clock
    <font color=#0000E0>mov</font> es:[di+80h*16+0],ax ;<font color=#808080> set IRQ 0 handler</font>
    <font color=#0000E0>shr</font> eax,16
    <font color=#0000E0>mov</font> es:[di+80h*16+6],ax

    <font color=#0000E0>mov</font> eax, ebx
    <font color=#0000E0>add</font> eax, offset keyboard
    <font color=#0000E0>mov</font> es:[di+81h*16+0],ax ;<font color=#808080> set IRQ 1 handler</font>
    <font color=#0000E0>shr</font> eax,16
    <font color=#0000E0>mov</font> es:[di+81h*16+6],ax

;<font color=#808080>--- clear NT flag</font>

    <font color=#0000E0>pushf</font>
    <font color=#0000E0>pop</font> ax
    <font color=#0000E0>and</font> ah,0BFh
    <font color=#0000E0>push</font> ax
    <font color=#0000E0>popf</font>

;<font color=#808080>--- reprogram PIC: change IRQ 0-7 to INT 80h-87h, IRQ 8-15 to INT 88h-8Fh</font>

    <font color=#0000E0>cli</font>
    <font color=#0000E0>in</font> al,0A1h
    <font color=#0000E0>mov</font> ah,al
    <font color=#0000E0>in</font> al,21h
    <font color=#0000E0>mov</font> [wPICMask],ax
    <font color=#0000E0>mov</font> al,10001b       ;<font color=#808080> begin PIC 1 initialization</font>
    <font color=#0000E0>out</font> 20h,al
    <font color=#0000E0>mov</font> al,10001b       ;<font color=#808080> begin PIC 2 initialization</font>
    <font color=#0000E0>out</font> 0A0h,al
    <font color=#0000E0>mov</font> al,80h          ;<font color=#808080> IRQ 0-7: interrupts 80h-87h</font>
    <font color=#0000E0>out</font> 21h,al
    <font color=#0000E0>mov</font> al,88h          ;<font color=#808080> IRQ 8-15: interrupts 88h-8Fh</font>
    <font color=#0000E0>out</font> 0A1h,al
    <font color=#0000E0>mov</font> al,100b         ;<font color=#808080> slave connected to IRQ2</font>
    <font color=#0000E0>out</font> 21h,al
    <font color=#0000E0>mov</font> al,2
    <font color=#0000E0>out</font> 0A1h,al
    <font color=#0000E0>mov</font> al,1            ;<font color=#808080> Intel environment, manual EOI</font>
    <font color=#0000E0>out</font> 21h,al
    <font color=#0000E0>out</font> 0A1h,al
    <font color=#0000E0>in</font> al,21h
    <font color=#0000E0>mov</font> al,11111100b    ;<font color=#808080> enable only clock and keyboard IRQ</font>
    <font color=#0000E0>out</font> 21h,al
    <font color=#0000E0>in</font> al,0A1h
    <font color=#0000E0>mov</font> al,11111111b
    <font color=#0000E0>out</font> 0A1h,al

    <font color=#0000E0>mov</font> eax,cr4
    <font color=#0000E0>or</font> eax,1 <font color=#0000E0>shl</font> 5
    <font color=#0000E0>mov</font> cr4,eax         ;<font color=#808080> enable physical-address extensions (PAE)</font>

    <font color=#0000E0>mov</font> ecx,0C0000080h  ;<font color=#808080> EFER MSR</font>

    <font color=#0000E0>rdmsr</font>
    <font color=#0000E0>or</font> eax,1 <font color=#0000E0>shl</font> 8      ;<font color=#808080> enable long mode</font>
    <font color=#0000E0>wrmsr</font>

    <font color=#0000E0>lgdt</font> [GDTR]
    <font color=#0000E0>lidt</font> [IDTR]

    <font color=#0000E0>mov</font> cx,ss
    <font color=#0000E0>movzx</font> ecx,cx        ;<font color=#808080> get base of SS</font>
    <font color=#0000E0>shl</font> ecx,4
    <font color=#0000E0>add</font> ecx, esp

    <font color=#0000E0>mov</font> eax,cr0
    <font color=#0000E0>or</font> eax,80000001h
    <font color=#0000E0>mov</font> cr0,eax         ;<font color=#808080> enable paging + pmode</font>

    <b>db</b> 66h, 0EAh        ;<font color=#808080> jmp 0008:oooooooo</font>
llg <b>dd</b> offset long_start
    <b>dw</b> 8

;<font color=#808080>--- switch back to real-mode and exit</font>

backtoreal:
    <font color=#0000E0>mov</font> eax,cr0
    <font color=#0000E0>and</font> eax,7FFFFFFFh   ;<font color=#808080> disable paging</font>
    <font color=#0000E0>mov</font> cr0,eax
    <font color=#0000E0>mov</font> ecx,0C0000080h  ;<font color=#808080> EFER MSR</font>
    <font color=#0000E0>rdmsr</font>
    <font color=#0000E0>and</font> ah,<font color=#0000E0>not</font> 1h       ;<font color=#808080> disable long mode (EFER.LME=0)</font>
    <font color=#0000E0>wrmsr</font>
    <font color=#0000E0>mov</font> ax,24
    <font color=#0000E0>mov</font> ss,ax
    <font color=#0000E0>mov</font> ds,ax
    <font color=#0000E0>mov</font> es,ax
    <font color=#0000E0>mov</font> eax,cr0
    <font color=#0000E0>and</font> al,0FEh
    <font color=#0000E0>mov</font> cr0, eax        ;<font color=#808080> back to real mode</font>
    <b>db</b> 0eah
    <b>dw</b> $+4
    <b>dw</b> _TEXT16
    <font color=#0000E0>mov</font> ax,STACK
    <font color=#0000E0>mov</font> ss, ax
    <font color=#0000E0>mov</font> sp,4096
    <font color=#0000E0>push</font> cs
    <font color=#0000E0>pop</font> ds
    <font color=#0000E0>lidt</font> [nullidt]
    <font color=#0000E0>mov</font> eax,cr4
    <font color=#0000E0>and</font> al,<font color=#0000E0>not</font> 20h
    <font color=#0000E0>mov</font> cr4,eax         ;<font color=#808080> disable physical-address extensions</font>

    <font color=#0000E0>mov</font> al,10001b       ;<font color=#808080> begin PIC 1 initialization</font>
    <font color=#0000E0>out</font> 20h,al
    <font color=#0000E0>mov</font> al,10001b       ;<font color=#808080> begin PIC 2 initialization</font>
    <font color=#0000E0>out</font> 0A0h,al
    <font color=#0000E0>mov</font> al,08h          ;<font color=#808080> IRQ 0-7: back to ints 8h-Fh</font>
    <font color=#0000E0>out</font> 21h,al
    <font color=#0000E0>mov</font> al,70h          ;<font color=#808080> IRQ 8-15: back to ints 70h-77h</font>
    <font color=#0000E0>out</font> 0A1h,al
    <font color=#0000E0>mov</font> al,100b         ;<font color=#808080> slave connected to IRQ2</font>
    <font color=#0000E0>out</font> 21h,al
    <font color=#0000E0>mov</font> al,2
    <font color=#0000E0>out</font> 0A1h,al
    <font color=#0000E0>mov</font> al,1            ;<font color=#808080> Intel environment, manual EOI</font>
    <font color=#0000E0>out</font> 21h,al
    <font color=#0000E0>out</font> 0A1h,al
    <font color=#0000E0>in</font> al,21h
    <font color=#0000E0>mov</font> ax,[wPICMask]   ;<font color=#808080> restore PIC masks</font>
    <font color=#0000E0>out</font> 21h,al
    <font color=#0000E0>mov</font> al,ah
    <font color=#0000E0>out</font> 0A1h,al
    <font color=#0000E0>sti</font>
    <font color=#0000E0>mov</font> ax,4c00h
    <font color=#0000E0>int</font> 21h

_TEXT16 <b>ends</b>

;<font color=#808080>--- here's the 64bit code segment.</font>
;<font color=#808080>--- since 64bit code is always flat but the DOS mz format is segmented,</font>
;<font color=#808080>--- there are restrictions, because the assembler doesn't know the</font>
;<font color=#808080>--- linear address where the 64bit segment will be loaded:</font>
;<font color=#808080>--- + direct addressing with constants isn't possible (mov [0B8000h],rax)</font>
;<font color=#808080>---   since the rip-relative address will be calculated wrong.</font>
;<font color=#808080>--- + 64bit offsets (mov rax, offset &lt;var&gt;) must be adjusted by the linear</font>
;<font color=#808080>---   address where the 64bit segment was loaded (is in rbx).</font>
;<font color=#808080>---</font>
;<font color=#808080>--- rbx must preserve linear address of _TEXT</font>

_TEXT <b>segment</b> para use64 public 'CODE'

    <b>assume</b> ds:FLAT, es:FLAT

long_start:

    <font color=#0000E0>xor</font> eax,eax
    <font color=#0000E0>mov</font> ss,eax
    <font color=#0000E0>mov</font> esp,ecx
    <font color=#0000E0>sti</font>             ;<font color=#808080> now interrupts can be used</font>
    <font color=#0000E0>call</font> WriteStrX
    <b>db</b> "Hello 64bit",10,0
nextcmd:
    <font color=#0000E0>mov</font> r8b,0       ;<font color=#808080> r8b will be filled by the keyboard irq routine</font>
nocmd:
    <font color=#0000E0>cmp</font> r8b,0
    <font color=#0000E0>jz</font> nocmd
    <font color=#0000E0>cmp</font> r8b,1       ;<font color=#808080> ESC?</font>
    <font color=#0000E0>jz</font> esc_pressed
    <font color=#0000E0>cmp</font> r8b,13h     ;<font color=#808080> 'r'?</font>
    <font color=#0000E0>jz</font> r_pressed
    <font color=#0000E0>call</font> WriteStrX
    <b>db</b> "unknown key ",0
    <font color=#0000E0>mov</font> al,r8b
    <font color=#0000E0>call</font> WriteB
    <font color=#0000E0>call</font> WriteStrX
    <b>db</b> 10,0
    jmp nextcmd

;<font color=#808080>--- 'r' key: display some register contents</font>

r_pressed:
    <font color=#0000E0>call</font> WriteStrX
    <b>db</b> 10,"cr0=",0
    <font color=#0000E0>mov</font> rax,cr0
    <font color=#0000E0>call</font> WriteQW
    <font color=#0000E0>call</font> WriteStrX
    <b>db</b> 10,"cr2=",0
    <font color=#0000E0>mov</font> rax,cr2
    <font color=#0000E0>call</font> WriteQW
    <font color=#0000E0>call</font> WriteStrX
    <b>db</b> 10,"cr3=",0
    <font color=#0000E0>mov</font> rax,cr3
    <font color=#0000E0>call</font> WriteQW
    <font color=#0000E0>call</font> WriteStrX
    <b>db</b> 10,"cr4=",0
    <font color=#0000E0>mov</font> rax,cr4
    <font color=#0000E0>call</font> WriteQW
    <font color=#0000E0>call</font> WriteStrX
    <b>db</b> 10,"cr8=",0
    <font color=#0000E0>mov</font> rax,cr8
    <font color=#0000E0>call</font> WriteQW
    <font color=#0000E0>call</font> WriteStrX
    <b>db</b> 10,0
    jmp nextcmd

;<font color=#808080>--- ESC: back to real-mode</font>

esc_pressed:
    jmp [bv]
bv  <b>label</b> fword
    <b>dd</b> offset backtoreal
    <b>dw</b> 16

;<font color=#808080>--- screen output helpers</font>

;<font color=#808080>--- scroll screen up one line</font>
;<font color=#808080>--- rsi = linear address start of last line</font>
;<font color=#808080>--- rbp = linear address of BIOS area (0x400)</font>
scroll_screen:
    <font color=#0000E0>cld</font>
    <font color=#0000E0>mov</font> rdi,rsi
    <font color=#0000E0>movzx</font> rax,word ptr [rbp+4Ah]
    <font color=#0000E0>push</font> rax
    <font color=#0000E0>lea</font> rsi, [rsi+2*rax]
    <font color=#0000E0>mov</font> CL, [rbp+84h]
    <font color=#0000E0>mul</font> cl
    <font color=#0000E0>mov</font> rcx,rax
    <font color=#0000E0>rep</font> <font color=#0000E0>movsw</font>
    <font color=#0000E0>pop</font> rcx
    <font color=#0000E0>mov</font> ax,0720h
    <font color=#0000E0>rep</font> <font color=#0000E0>stosw</font>
    <font color=#0000E0>ret</font>

WriteChr:
    <font color=#0000E0>push</font> rbp
    <font color=#0000E0>push</font> rdi
    <font color=#0000E0>push</font> rsi
    <font color=#0000E0>push</font> rbx
    <font color=#0000E0>push</font> rcx
    <font color=#0000E0>push</font> rdx
    <font color=#0000E0>push</font> rax
    <font color=#0000E0>mov</font> rdi,0B8000h
    <font color=#0000E0>mov</font> rbp,400h
    <font color=#0000E0>cmp</font> BYTE ptr [rbp+63h],0B4h
    <font color=#0000E0>jnz</font> @F
    <font color=#0000E0>xor</font> DI,DI
@@:
    <font color=#0000E0>movzx</font> rbx, WORD PTR [rbp+4Eh]
    <font color=#0000E0>add</font> rdi, rbx
    <font color=#0000E0>movzx</font> rbx, BYTE PTR [rbp+62h]
    <font color=#0000E0>mov</font> rsi, rdi
    <font color=#0000E0>movzx</font> rcx, BYTE PTR [rbx*2+rbp+50h+1] ;<font color=#808080>ROW</font>
    <font color=#0000E0>movzx</font> rax, WORD PTR [rbp+4Ah]
    <font color=#0000E0>mul</font> rcx
    <font color=#0000E0>movzx</font> rdx, BYTE PTR [rbx*2+rbp+50h]  ;<font color=#808080>COL</font>
    <font color=#0000E0>add</font> rax, rdx
    <font color=#0000E0>mov</font> DH,CL
    <font color=#0000E0>lea</font> rdi, [rdi+rax*2]
    <font color=#0000E0>mov</font> AL, [rsp]
    <font color=#0000E0>cmp</font> AL, 10
    <font color=#0000E0>jz</font> newline
    <font color=#0000E0>mov</font> [rdi], AL
    <font color=#0000E0>mov</font> byte ptr [rdi+1], 07
    <font color=#0000E0>inc</font> DL
    <font color=#0000E0>cmp</font> DL, BYTE PTR [rbp+4Ah]
    <font color=#0000E0>jb</font> @F
newline:
    <font color=#0000E0>mov</font> DL, 00
    <font color=#0000E0>inc</font> DH
    <font color=#0000E0>cmp</font> DH, BYTE PTR [rbp+84h]
    <font color=#0000E0>jbe</font> @F
    <font color=#0000E0>dec</font> DH
    <font color=#0000E0>call</font> scroll_screen
@@:
    <font color=#0000E0>mov</font> [rbx*2+rbp+50h],DX
    <font color=#0000E0>pop</font> rax
    <font color=#0000E0>pop</font> rdx
    <font color=#0000E0>pop</font> rcx
    <font color=#0000E0>pop</font> rbx
    <font color=#0000E0>pop</font> rsi
    <font color=#0000E0>pop</font> rdi
    <font color=#0000E0>pop</font> rbp
    <font color=#0000E0>ret</font>

WriteStr:   ;<font color=#808080>write string in rdx</font>
    <font color=#0000E0>push</font> rsi
    <font color=#0000E0>mov</font> rsi, rdx
    <font color=#0000E0>cld</font>
@@:
    <font color=#0000E0>lodsb</font>
    <font color=#0000E0>and</font> al,al
    <font color=#0000E0>jz</font> @F
    <font color=#0000E0>call</font> WriteChr
    jmp @B
@@:
    <font color=#0000E0>pop</font> rsi
    <font color=#0000E0>ret</font>

WriteStrX:  ;<font color=#808080>write string at rip</font>
    <font color=#0000E0>push</font> rsi
    <font color=#0000E0>mov</font> rsi, [rsp+8]
    <font color=#0000E0>cld</font>
@@:
    <font color=#0000E0>lodsb</font>
    <font color=#0000E0>and</font> al,al
    <font color=#0000E0>jz</font> @F
    <font color=#0000E0>call</font> WriteChr
    jmp @B
@@:
    <font color=#0000E0>mov</font> [rsp+8],rsi
    <font color=#0000E0>pop</font> rsi
    <font color=#0000E0>ret</font>

WriteQW:        ;<font color=#808080>write QWord in rax</font>
    <font color=#0000E0>push</font> rax
    <font color=#0000E0>shr</font> rax,32
    <font color=#0000E0>call</font> WriteDW
    <font color=#0000E0>pop</font> rax
WriteDW:
    <font color=#0000E0>push</font> rax
    <font color=#0000E0>shr</font> rax,16
    <font color=#0000E0>call</font> WriteW
    <font color=#0000E0>pop</font> rax
WriteW:
    <font color=#0000E0>push</font> rax
    <font color=#0000E0>shr</font> rax,8
    <font color=#0000E0>call</font> WriteB
    <font color=#0000E0>pop</font> rax
WriteB:     ;<font color=#808080>write Byte in al</font>
    <font color=#0000E0>push</font> rax
    <font color=#0000E0>shr</font> rax,4
    <font color=#0000E0>call</font> WriteNb
    <font color=#0000E0>pop</font> rax
WriteNb:
    <font color=#0000E0>and</font> al,0Fh
    <font color=#0000E0>add</font> al,'0'
    <font color=#0000E0>cmp</font> al,'9'
    <font color=#0000E0>jbe</font> @F
    <font color=#0000E0>add</font> al,7
@@:
    jmp WriteChr

;<font color=#808080>--- exception handler</font>

exception:
excno = 0
    <b>repeat</b> 32
    <font color=#0000E0>push</font> excno
    jmp @F
    excno = excno+1
    <b>endm</b>
@@:
    <font color=#0000E0>call</font> WriteStrX
    <b>db</b> 10,"Exception ",0
    <font color=#0000E0>pop</font> rax
    <font color=#0000E0>call</font> WriteB
    <font color=#0000E0>call</font> WriteStrX
    <b>db</b> " errcode=",0
    <font color=#0000E0>mov</font> rax,[rsp+0]
    <font color=#0000E0>call</font> WriteQW
    <font color=#0000E0>call</font> WriteStrX
    <b>db</b> " rip=",0
    <font color=#0000E0>mov</font> rax,[rsp+8]
    <font color=#0000E0>call</font> WriteQW
    <font color=#0000E0>call</font> WriteStrX
    <b>db</b> 10,0
@@:
    jmp $

;<font color=#808080>--- clock and keyboard interrupts</font>

clock:
    <font color=#0000E0>push</font> rbp
    <font color=#0000E0>mov</font> rbp,400h
    <font color=#0000E0>inc</font> dword ptr [rbp+6Ch]
    <font color=#0000E0>pop</font> rbp
interrupt:              ;<font color=#808080> handler for all other interrupts</font>
    <font color=#0000E0>push</font> rax
    <font color=#0000E0>mov</font> al,20h
    <font color=#0000E0>out</font> 20h,al
    <font color=#0000E0>pop</font> rax
    iretq

keyboard:
    <font color=#0000E0>push</font> rax
    <font color=#0000E0>in</font> al,60h
    <font color=#0000E0>test</font> al,80h
    <font color=#0000E0>jnz</font> @F
    <font color=#0000E0>mov</font> r8b, al
@@:
    <font color=#0000E0>in</font> al,61h           ;<font color=#808080> give finishing information</font>
    <font color=#0000E0>out</font> 61h,al          ;<font color=#808080> to keyboard...</font>
    <font color=#0000E0>mov</font> al,20h
    <font color=#0000E0>out</font> 20h,al          ;<font color=#808080> ...and interrupt controller</font>
    <font color=#0000E0>pop</font> rax
    iretq

_TEXT <b>ends</b>

;<font color=#808080>--- 4k stack, used in both modes</font>

STACK <b>segment</b> use16 para stack 'STACK'
    <b>db</b> 4096 dup (?)
STACK <b>ends</b>

    <b>end</b> start16
</pre>
</TD></TR>
</TABLE>

<H2 ID="AB04"> Win32_5 - Create a Win32 Binary with -bin </H1>

<TABLE BORDER=0 CELLSPACING=4 CELLPADDING=4 WIDTH="100%">
<TR BGCOLOR=#E0E0E0><TD>
<pre>

;<font color=#808080>--- Win32 "hello world" console application.</font>
;<font color=#808080>--- Uses JWasm's bin output format, so no linker needed.</font>
;<font color=#808080>--- assemble: JWasm -bin -Fo Win32_5.exe Win32_5.ASM</font>

    <b>.386</b>
    <b>option</b> casemap:none

    <b>.nolist</b>
    <b>include</b> winnt.inc   ;<font color=#808080>include PE image definitions</font>
    <b>.list</b>

STD_OUTPUT_HANDLE <b>equ</b> -11

IMAGEBASE <b>equ</b> 400000h

PEHDR <b>segment</b> dword FLAT

;<font color=#808080>--- define the DOS "MZ" header</font>

    <b>org</b> IMAGEBASE

    IMAGE_DOS_HEADER &lt;"ZM", 80h, 1, 0,4,0,-1,0,200h,0,0,0,0,0,&lt;0&gt;,0,0,&lt;0&gt;,IMAGEREL PEHdr&gt;

    <b>db</b> 0Eh         ;<font color=#808080>push cs</font>
    <b>db</b> 1Fh         ;<font color=#808080>pop ds</font>
    <b>db</b> 0BAh,0Eh,0  ;<font color=#808080>mov dx,text</font>
    <b>db</b> 0B4h,09h    ;<font color=#808080>mov ah,9</font>
    <b>db</b> 0CDh,21h    ;<font color=#808080>int 21h</font>
    <b>db</b> 0B8h,01h,4Ch;<font color=#808080>mov ax,4c01h</font>
    <b>db</b> 0CDh,21h    ;<font color=#808080>int 21h</font>
    <b>db</b> "This program cannot be run in DOS mode",13,10,'$'

    <b>org</b> IMAGEBASE+80h

;<font color=#808080>--- define the Win32 "PE" header</font>

PEHdr <b>label</b> byte
    <b>db</b> "PE",0,0
    IMAGE_FILE_HEADER &lt;IMAGE_FILE_MACHINE_I386, num_sections, 0, 0, 0, sizeof IMAGE_OPTIONAL_HEADER32,
        IMAGE_FILE_RELOCS_STRIPPED or IMAGE_FILE_EXECUTABLE_IMAGE or IMAGE_FILE_32BIT_MACHINE or IMAGE_FILE_LOCAL_SYMS_STRIPPED&gt;

    IMAGE_OPTIONAL_HEADER32 { 10Bh, ;<font color=#808080>magic</font>
        6,0,                        ;<font color=#808080>linker major, minor</font>
        1000h,1000h,0,              ;<font color=#808080>sizeof code, initialized data, uninitialized data</font>
        IMAGEREL mainCRTStartup,    ;<font color=#808080>entry point</font>
        IMAGEREL start_text, IMAGEREL start_rdata,  ;<font color=#808080>baseof code, data</font>
        IMAGEBASE,    ;<font color=#808080>imagebase</font>
        1000h,200h,   ;<font color=#808080>section alignment, file alignment</font>
        4,0,          ;<font color=#808080>OS major, minor</font>
        0,0,          ;<font color=#808080>Image major, minor</font>
        4,0,          ;<font color=#808080>Subsys major, minor</font>
        0,            ;<font color=#808080>win32 version</font>
        3000h,        ;<font color=#808080>sizeof image</font>
        1000h,        ;<font color=#808080>sizeof header</font>
        0,            ;<font color=#808080>checksum</font>
        IMAGE_SUBSYSTEM_WINDOWS_CUI,
        0,            ;<font color=#808080>dll characteristics</font>
        100000h,1000h,;<font color=#808080>stack res,com</font>
        100000h,1000h,;<font color=#808080>heap res, com</font>
        0,            ;<font color=#808080>loader flags</font>
        16,           ;<font color=#808080>number of directories</font>
        &lt;&lt;0,0&gt;,       ;exports
        &lt; IMAGEREL start_idata, SECTIONREL endof_idata &gt;, ;<font color=#808080>imports</font>
        &lt;0,0&gt;,&lt;0,0&gt;,     ;<font color=#808080>resource, exception</font>
        &lt;&gt;,&lt;&gt;,&lt;&gt;,&lt;&gt;,     ;<font color=#808080>security, baserelocs, debug, architecture</font>
        &lt;&gt;,&lt;&gt;,&lt;&gt;,&lt;&gt;,     ;<font color=#808080>globalptr, tls, load_config, bound_import</font>
        &lt;&gt;,&lt;&gt;,&lt;&gt;,&lt;&gt;&gt;}    ;<font color=#808080>iat, delay_import, com descriptor, reserved</font>

;<font color=#808080>--- define the section table</font>

sectiontable <b>label</b> byte
    IMAGE_SECTION_HEADER &lt;".text", &lt;sizeof_text&gt;, IMAGEREL start_text, sizeof_text,
        200h, 0, 0, 0, 0, 060000020h &gt;
    IMAGE_SECTION_HEADER &lt;".rdata", &lt;SECTIONREL endof_idata + sizeof_const&gt;, IMAGEREL start_rdata, SECTIONREL endof_idata + sizeof_const,
        400h, 0, 0, 0, 0, 040000040h &gt;
num_sections <b>equ</b> ( $ -  sectiontable ) / sizeof IMAGE_SECTION_HEADER

    <b>org</b> IMAGEBASE+200h   ;<font color=#808080>forces physical size of header to 200h and sets VA to 400200h</font>

PEHDR <b>ends</b>

;<font color=#808080>--- the ALIGNx segments are needed because</font>
;<font color=#808080>--- section alignment and file alignment are different</font>

ALIGN1 <b>segment</b> dword public FLAT 'DATA'
    <b>org</b> 0E00h   ;<font color=#808080> change pc to RVA 1000h</font>
ALIGN1 <b>ends</b>

_TEXT <b>segment</b> dword public FLAT 'CODE'
_TEXT <b>ends</b>

ALIGN2 <b>segment</b> dword public FLAT 'DATA'
    <b>org</b> 0E00h   ;<font color=#808080> change pc to RVA 2000h</font>
ALIGN2 <b>ends</b>

_IDATA <b>segment</b> dword public FLAT 'DATA'
start_rdata <b>label</b> byte
start_idata <b>label</b> byte
;<font color=#808080>--- import descriptors go here</font>
_IDATA <b>ends</b>
_IDATA$1 <b>segment</b> dword public FLAT 'DATA'
    IMAGE_IMPORT_DESCRIPTOR &lt;&lt;0&gt;,0,0,0,0&gt;
;<font color=#808080>--- ILT entries go here</font>
_IDATA$1 <b>ends</b>
_IDATA$2 <b>segment</b> dword public FLAT 'DATA'
    <b>dd</b> 0    ;<font color=#808080>--- end of last ILT</font>
;<font color=#808080>--- IAT entries go here</font>
_IDATA$2 <b>ends</b>
_IDATA$3 <b>segment</b> dword public FLAT 'DATA'
    <b>dd</b> 0    ;<font color=#808080>--- end of last IAT</font>
;<font color=#808080>--- import name strings go here</font>
_IDATA$3 <b>ends</b>
_IDATA$4 <b>segment</b> dword public FLAT 'DATA'
endof_idata <b>equ</b> $
_IDATA$4 <b>ends</b>

CONST <b>segment</b> dword public FLAT 'DATA'
start_const <b>label</b> byte
CONST <b>ends</b>

DefineImpDll <b>macro</b> name
_IDATA <b>segment</b>
    IMAGE_IMPORT_DESCRIPTOR &lt;&lt;IMAGEREL name&amp;ILT&gt;,0,0,IMAGEREL name, IMAGEREL name&amp;IAT&gt;
_IDATA <b>ends</b>
_IDATA$1 <b>segment</b>
<b>ifdef</b> ImportDefined
    <b>dd</b> 0  ;<font color=#808080>terminate previous ILT</font>
<b>endif</b>
<b>name</b>&amp;ILT label dword
_IDATA$1 <b>ends</b>
_IDATA$2 <b>segment</b>
<b>ifdef</b> ImportDefined
    <b>dd</b> 0  ;<font color=#808080>terminate previous IAT</font>
<b>endif</b>
<b>name</b>&amp;IAT label dword
_IDATA$2 <b>ends</b>
_IDATA$3 <b>segment</b>
<b>name</b> db @CatStr(!",name, !"),0
    <b>align</b> 4
_IDATA$3 <b>ends</b>
ImportDefined <b>equ</b> 1
    <b>endm</b>

DefineImport <b>macro</b> name
_IDATA$1 <b>segment</b>
    <b>dd</b> IMAGEREL n&amp;name
_IDATA$1 <b>ends</b>
_IDATA$2 <b>segment</b>
lp&amp;<b>name</b> typedef ptr pr&amp;name
<b>name</b>    lp&amp;name IMAGEREL n&amp;name
_IDATA$2 <b>ends</b>
_IDATA$3 <b>segment</b>
n&amp;<b>name</b> dw 0
    <b>db</b> @CatStr(!",name, !"),0
    <b>align</b> 4
_IDATA$3 <b>ends</b>
    <b>endm</b>

prWriteConsoleA <b>typedef</b> proto stdcall :dword, :dword, :dword, :dword, :dword
prGetStdHandle  <b>typedef</b> proto stdcall :dword
prExitProcess   <b>typedef</b> proto stdcall :dword

    DefineImpDll kernel32
    DefineImport ExitProcess
    DefineImport WriteConsoleA
    DefineImport GetStdHandle

<b>if</b> 0 ;<font color=#808080>if further dlls are to be imported</font>
prMessageBoxA   <b>typedef</b> proto stdcall :dword, :dword, :dword, :dword

    DefineImpDll user32
    DefineImport MessageBoxA
<b>endif</b>

CONST <b>segment</b>

string  <b>db</b> 13,10,"hello, world.",13,10

sizeof_const <b>equ</b> $ - start_const

CONST <b>ends</b>

_TEXT <b>segment</b>

    <b>assume</b> ds:FLAT,es:FLAT

start_text <b>label</b> near

;<font color=#808080>--- start of program</font>

main <b>proc</b>

<b>local</b> dwWritten:dword
<b>local</b> hConsole:dword

    <b>invoke</b>  GetStdHandle, STD_OUTPUT_HANDLE
    mov     hConsole,eax

    <b>invoke</b>  WriteConsoleA, hConsole, addr string, sizeof string, addr dwWritten, 0

    xor     eax,eax
    ret
main <b>endp</b>

;<font color=#808080>--- entry</font>

mainCRTStartup <b>proc</b> c

    <b>invoke</b>  main
    <b>invoke</b>  ExitProcess, eax

mainCRTStartup <b>endp</b>

sizeof_text <b>equ</b> $ - start_text

    <b>org</b> 200h    ;<font color=#808080>align size of _TEXT to next 512 byte boundary</font>

_TEXT <b>ends</b>

    <b>end</b>
</pre>
</TD></TR>
</TABLE>

<H2 ID="AB05"> Win32_7 - Usage of OPTION DLLIMPORT and -Fd Switch </H1>

<TABLE BORDER=0 CELLSPACING=4 CELLPADDING=4 WIDTH="100%">
<TR BGCOLOR=#E0E0E0><TD>
<pre>

;<font color=#808080>--- Win32_7 - Shows how to use OPTION DLLIMPORT and switch -Fd.</font>
;<font color=#808080>---           No import libraries are needed in the link step.</font>
;<font color=#808080>---</font>
;<font color=#808080>--- assemble: JWasm -coff -Fd Win32_7.ASM</font>
;<font color=#808080>--- link:     JWlink format windows pe f Win32_7.OBJ</font>

    <b>.386</b>
    <b>.model</b> FLAT, stdcall
    <b>option</b> casemap:none

STD_OUTPUT_HANDLE <b>equ</b> -11

   <b>option</b> dllimport:&lt;kernel32&gt;
WriteConsoleA <b>proto</b> :dword, :dword, :dword, :dword, :dword
GetStdHandle  <b>proto</b> :dword
ExitProcess   <b>proto</b> :dword
   <b>option</b> dllimport:&lt;user32&gt;
MessageBoxA   <b>proto</b> :dword, :dword, :dword, :dword
   <b>option</b> dllimport:&lt;none&gt;

    <b>.const</b>

msg <b>db</b> 13,10,"hello, world.",13,10
    <b>db</b> 0

    <b>.code</b>

main <b>proc</b>

<b>local</b>   written:dword

    <b>invoke</b>  GetStdHandle, STD_OUTPUT_HANDLE
    mov ebx, eax
    <b>invoke</b>  WriteConsoleA, ebx, addr msg, sizeof msg,
                addr written, 0
    <b>invoke</b>  MessageBoxA, 0, addr msg, 0, 0
    ret

main <b>endp</b>

;<font color=#808080>--- entry</font>

start:

    <b>invoke</b>  main
    <b>invoke</b>  ExitProcess, 0

    <b>end</b> start
</pre>
</TD></TR>
</TABLE>

</BODY>
</HTML>
